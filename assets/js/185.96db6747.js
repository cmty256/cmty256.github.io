(window.webpackJsonp=window.webpackJsonp||[]).push([[185],{517:function(_,v,t){"use strict";t.r(v);var a=t(1),r=Object(a.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h1",{attrs:{id:"消息堆积处理方案"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#消息堆积处理方案"}},[_._v("#")]),_._v(" 消息堆积处理方案")]),_._v(" "),v("p",[_._v("处理消息堆积是分布式系统和消息队列架构中的"),v("strong",[_._v("高频面试题")]),_._v("和"),v("strong",[_._v("实战问题")]),_._v("，需要从"),v("strong",[_._v("监控、定位、扩容、削峰、限流、重构")]),_._v("等多个角度去分析和解决。")]),_._v(" "),v("h2",{attrs:{id:"什么是消息堆积"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是消息堆积"}},[_._v("#")]),_._v(" 什么是消息堆积？")]),_._v(" "),v("p",[v("strong",[_._v("消息堆积")]),_._v("指的是：消息生产者发送速度 > 消费者处理速度，导致消息在 Broker 中越积越多，严重时会"),v("strong",[_._v("触发系统报警甚至 OOM 崩溃")]),_._v("。")]),_._v(" "),v("h2",{attrs:{id:"定位消息堆积的原因"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#定位消息堆积的原因"}},[_._v("#")]),_._v(" 定位消息堆积的原因")]),_._v(" "),v("p",[_._v("常见原因：")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("原因")]),_._v(" "),v("th",[_._v("说明")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[_._v("消费端宕机")]),_._v(" "),v("td",[_._v("无法正常拉取消息")])]),_._v(" "),v("tr",[v("td",[_._v("消费端处理慢")]),_._v(" "),v("td",[_._v("业务处理耗时长，如调用慢接口")])]),_._v(" "),v("tr",[v("td",[_._v("消费端线程太少")]),_._v(" "),v("td",[_._v("无法并发处理大量消息")])]),_._v(" "),v("tr",[v("td",[_._v("消息量突增")]),_._v(" "),v("td",[_._v("秒杀/大促等瞬时高流量")])]),_._v(" "),v("tr",[v("td",[_._v("死信消息未清理")]),_._v(" "),v("td",[_._v("消息重复消费失败，卡死积压")])]),_._v(" "),v("tr",[v("td",[_._v("网络延迟/带宽瓶颈")]),_._v(" "),v("td",[_._v("消费端到 broker 的网络问题")])])])]),_._v(" "),v("h2",{attrs:{id:"处理消息堆积的策略"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#处理消息堆积的策略"}},[_._v("#")]),_._v(" 处理消息堆积的策略")]),_._v(" "),v("h3",{attrs:{id:"_1-快速扩容消费端"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-快速扩容消费端"}},[_._v("#")]),_._v(" 1. 快速扩容消费端")]),_._v(" "),v("p",[v("strong",[_._v("横向扩容")]),_._v("是最直接有效的方式：")]),_._v(" "),v("ul",[v("li",[_._v("增加消费者实例数（Kafka 增加消费者组成员，RocketMQ 新建多个消费者进程）")]),_._v(" "),v("li",[_._v("增加每个消费者的线程池大小，提升消费吞吐量")])]),_._v(" "),v("h3",{attrs:{id:"_2-开启并发消费-多线程处理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-开启并发消费-多线程处理"}},[_._v("#")]),_._v(" 2. 开启并发消费 / 多线程处理")]),_._v(" "),v("ul",[v("li",[_._v("Kafka 使用多线程 "),v("code",[_._v("poll")]),_._v(" + 线程池处理业务逻辑")]),_._v(" "),v("li",[_._v("RocketMQ 设置 "),v("code",[_._v("consumeMessageBatchMaxSize")]),_._v(" 和线程数")]),_._v(" "),v("li",[_._v("避免串行消费逻辑")])]),_._v(" "),v("h3",{attrs:{id:"_3-优化消费逻辑"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-优化消费逻辑"}},[_._v("#")]),_._v(" 3. 优化消费逻辑")]),_._v(" "),v("p",[_._v("比如：")]),_._v(" "),v("ul",[v("li",[_._v("把同步远程调用改成异步")]),_._v(" "),v("li",[_._v("数据库操作改成批量插入")]),_._v(" "),v("li",[_._v("避免事务过大、索引不走等慢 SQL")]),_._v(" "),v("li",[_._v("减少不必要的业务判断、日志打印等")])]),_._v(" "),v("h3",{attrs:{id:"_4-使用消费补偿机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-使用消费补偿机制"}},[_._v("#")]),_._v(" 4. 使用消费补偿机制")]),_._v(" "),v("p",[_._v("当消费失败时：")]),_._v(" "),v("ul",[v("li",[_._v("限次数重试（避免死循环）")]),_._v(" "),v("li",[_._v("将失败消息投递到死信队列（DLQ）")]),_._v(" "),v("li",[_._v("定时任务异步处理补偿逻辑")])]),_._v(" "),v("h3",{attrs:{id:"_5-使用消息优先级-分流"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-使用消息优先级-分流"}},[_._v("#")]),_._v(" 5. 使用消息优先级 / 分流")]),_._v(" "),v("ul",[v("li",[_._v("将重要消息单独走高优先级 topic 或 consumer")]),_._v(" "),v("li",[_._v("热点数据 / 非热点数据拆开消费")]),_._v(" "),v("li",[_._v("按业务类型拆分队列，防止被长耗时消息阻塞")])]),_._v(" "),v("h3",{attrs:{id:"_6-使用限流-削峰"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-使用限流-削峰"}},[_._v("#")]),_._v(" 6. 使用限流+削峰")]),_._v(" "),v("ul",[v("li",[_._v("入口处限流（令牌桶 / 漏桶）")]),_._v(" "),v("li",[_._v("将高并发请求转为消息异步处理（削峰）")]),_._v(" "),v("li",[_._v("使用缓存/本地消息缓冲减少写库压力")])]),_._v(" "),v("h3",{attrs:{id:"_7-增加-partition-queue-数量"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-增加-partition-queue-数量"}},[_._v("#")]),_._v(" 7. 增加 Partition / Queue 数量")]),_._v(" "),v("ul",[v("li",[_._v("Kafka 增加 partition，可提高并发消费能力（但注意消息顺序）")]),_._v(" "),v("li",[_._v("RocketMQ 增加队列数或 topic 分片")])]),_._v(" "),v("h3",{attrs:{id:"_8-监控与报警"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_8-监控与报警"}},[_._v("#")]),_._v(" 8. 监控与报警")]),_._v(" "),v("p",[_._v("必须配合实时的监控与报警：")]),_._v(" "),v("ul",[v("li",[_._v("消费堆积长度（topic lag）")]),_._v(" "),v("li",[_._v("消息消费成功/失败率")]),_._v(" "),v("li",[_._v("消费延迟/耗时")]),_._v(" "),v("li",[_._v("消费异常日志")])]),_._v(" "),v("h2",{attrs:{id:"模拟场景与对策"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#模拟场景与对策"}},[_._v("#")]),_._v(" 模拟场景与对策")]),_._v(" "),v("p",[_._v("场景：我们使用 Kafka 作为异步处理通道，在高峰期发现消息堆积。")]),_._v(" "),v("p",[v("strong",[_._v("我的应对措施：")])]),_._v(" "),v("ol",[v("li",[_._v("通过监控系统发现某个 topic lag 超过阈值；")]),_._v(" "),v("li",[_._v("先排查消费端是否存在消费失败或处理慢，确认是某个接口慢；")]),_._v(" "),v("li",[_._v("我将该接口做了异步优化，DB 写操作改为批量；")]),_._v(" "),v("li",[_._v("同时扩容了消费线程池和实例数；")]),_._v(" "),v("li",[_._v("对失败消息引入重试 + 死信队列，确保消费成功率；")]),_._v(" "),v("li",[_._v("对入口流量做限流和缓存降压，避免产生更多堆积；")]),_._v(" "),v("li",[_._v("最后加了 dashboard + 消费报警，确保下次能提前发现问题。")])]),_._v(" "),v("h2",{attrs:{id:"总结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[_._v("#")]),_._v(" 总结")]),_._v(" "),v("p",[_._v("消息堆积通常是消费处理能力不足引起的，可以通过"),v("strong",[_._v("扩容消费者、优化消费逻辑、异步重试补偿、限流削峰、增加分区数量")]),_._v("等方式解决，同时配合"),v("strong",[_._v("监控和报警")]),_._v("及时发现问题。")])])}),[],!1,null,null,null);v.default=r.exports}}]);