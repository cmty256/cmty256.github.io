(window.webpackJsonp=window.webpackJsonp||[]).push([[128],{456:function(a,s,t){"use strict";t.r(s);var n=t(1),e=Object(n.a)({},(function(){var a=this,s=a._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h1",{attrs:{id:"kafka"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#kafka"}},[a._v("#")]),a._v(" Kafka")]),a._v(" "),s("p",[a._v("官方文档：")]),a._v(" "),s("p",[s("a",{attrs:{href:"https://kafka.apache.org/documentation/",target:"_blank",rel:"noopener noreferrer"}},[a._v("https://kafka.apache.org/documentation/"),s("OutboundLink")],1)]),a._v(" "),s("p",[s("a",{attrs:{href:"https://kafka.apachecn.org/",target:"_blank",rel:"noopener noreferrer"}},[a._v("Kafka 中文文档 - ApacheCN"),s("OutboundLink")],1)]),a._v(" "),s("h2",{attrs:{id:"快速开始"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#快速开始"}},[a._v("#")]),a._v(" 快速开始")]),a._v(" "),s("div",{staticClass:"language-bash line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("vim")]),a._v(" config/server.properties\n\n"),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[a._v("log.dirs")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("/usr/local/kafka/logs\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br")])]),s("p",[s("em",[a._v("关闭 kafka")])]),a._v(" "),s("p",[a._v("1、"),s("strong",[a._v("一定要先关闭 kafka，再关闭zookeeper，否则容易出现数据错乱")])]),a._v(" "),s("blockquote",[s("p",[a._v("如果出现数据错错乱，最简单的方法就是清空 data 和 kafka-logs 这两个文件下的内容，重新启动即可")])]),a._v(" "),s("p",[a._v("2、关闭")]),a._v(" "),s("div",{staticClass:"language-shell line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[a._v("."),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("\\")]),a._v("bin"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("\\")]),a._v("windows"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("\\")]),a._v("kafka-server-stop.bat\n."),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("\\")]),a._v("bin"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("\\")]),a._v("windows"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("\\")]),a._v("zookeeper-server-stop.bat\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br")])]),s("p",[a._v("参考文章：")]),a._v(" "),s("p",[s("a",{attrs:{href:"https://jishuzhan.net/article/1691789483743121409",target:"_blank",rel:"noopener noreferrer"}},[a._v("Kafka的下载安装以及使用 - 技术栈 (jishuzhan.net)"),s("OutboundLink")],1)]),a._v(" "),s("h2",{attrs:{id:"整合-springboot"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#整合-springboot"}},[a._v("#")]),a._v(" 整合 SpringBoot")]),a._v(" "),s("p",[s("em",[a._v("参考文章")]),a._v("：")]),a._v(" "),s("p",[s("a",{attrs:{href:"https://jishuzhan.net/article/1693427405168840705",target:"_blank",rel:"noopener noreferrer"}},[a._v("kafka安装说明以及在项目中使用"),s("OutboundLink")],1)]),a._v(" "),s("p",[s("a",{attrs:{href:"https://blog.csdn.net/qq_43631716/article/details/120024681",target:"_blank",rel:"noopener noreferrer"}},[a._v("SpringBoot整合Kafka"),s("OutboundLink")],1)]),a._v(" "),s("p",[a._v("项目启动后，运行")]),a._v(" "),s("div",{staticClass:"language-url line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-url"}},[s("code",[s("span",{pre:!0,attrs:{class:"token scheme"}},[a._v("localhost"),s("span",{pre:!0,attrs:{class:"token scheme-delimiter"}},[a._v(":")])]),s("span",{pre:!0,attrs:{class:"token path"}},[a._v("8080"),s("span",{pre:!0,attrs:{class:"token path-separator"}},[a._v("/")]),a._v("send")]),s("span",{pre:!0,attrs:{class:"token query"}},[s("span",{pre:!0,attrs:{class:"token query-delimiter"}},[a._v("?")]),s("span",{pre:!0,attrs:{class:"token pair"}},[s("span",{pre:!0,attrs:{class:"token key"}},[a._v("msg")]),a._v("="),s("span",{pre:!0,attrs:{class:"token value"}},[a._v("testSpringBootKafka")])])]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token scheme"}},[a._v("localhost"),s("span",{pre:!0,attrs:{class:"token scheme-delimiter"}},[a._v(":")])]),s("span",{pre:!0,attrs:{class:"token path"}},[a._v("8080"),s("span",{pre:!0,attrs:{class:"token path-separator"}},[a._v("/")]),a._v("test"),s("span",{pre:!0,attrs:{class:"token path-separator"}},[a._v("/")]),a._v("mock")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br")])]),s("p",[s("em",[a._v("Telnet 指令")])]),a._v(" "),s("p",[a._v("Telnet 是一种用于远程登录和管理网络设备的协议，同时也是基于这个协议的命令行工具。下面是一些常用的 Telnet 命令：")]),a._v(" "),s("ol",[s("li",[s("p",[a._v("连接到远程主机：")]),a._v(" "),s("div",{staticClass:"language-bash line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[a._v("telnet "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),a._v("host"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),a._v("port"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br")])])]),a._v(" "),s("li",[s("p",[a._v("将 "),s("code",[a._v("<host>")]),a._v(" 替换为要连接的远程主机的 IP 地址或主机名，将 "),s("code",[a._v("<port>")]),a._v(" 替换为要连接的端口号。例如，telnet example.com 23 将连接到 example.com 的 23 端口。")])]),a._v(" "),s("li",[s("p",[a._v("发送命令或数据：")]),a._v(" "),s("p",[a._v("在 Telnet 连接建立后，你可以直接在命令行中输入命令或数据，并按 Enter 键发送给远程主机。例如，输入 ls 命令查看远程主机上的文件列表。")])]),a._v(" "),s("li",[s("p",[a._v("退出 Telnet 连接：")]),a._v(" "),s("p",[a._v("在 Telnet 连接中，你可以使用以下命令之一来退出：")]),a._v(" "),s("ul",[s("li",[a._v("输入 quit 或 exit 命令并按 Enter 键。")]),a._v(" "),s("li",[a._v("按下 "),s("code",[a._v("Ctrl + ]")]),a._v("，然后输入 quit 命令并按 Enter 键。")])])])]),a._v(" "),s("p",[a._v("注意，Telnet 是一种明文协议，数据在传输过程中不会被加密，因此不建议在不安全的网络环境中使用 Telnet。对于安全连接，建议使用 SSH（Secure Shell）协议来进行远程登录和管理。")]),a._v(" "),s("h2",{attrs:{id:"可视化界面"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#可视化界面"}},[a._v("#")]),a._v(" 可视化界面")]),a._v(" "),s("p",[a._v("v1.0.8 版本："),s("a",{attrs:{href:"https://gitee.com/xiaodong_xu/kafka-console-ui/releases/download/v1.0.8/kafka-console-ui.zip",target:"_blank",rel:"noopener noreferrer"}},[a._v("gitee来源kafka-console-ui.zip"),s("OutboundLink")],1)]),a._v(" "),s("h3",{attrs:{id:"快速启动"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#快速启动"}},[a._v("#")]),a._v(" 快速启动")]),a._v(" "),s("h4",{attrs:{id:"windows"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#windows"}},[a._v("#")]),a._v(" Windows")]),a._v(" "),s("ol",[s("li",[a._v("解压缩 zip 安装包")]),a._v(" "),s("li",[a._v("进入 bin 目录（必须在 bin 目录下），双击执行 "),s("code",[a._v("start.bat")]),a._v(" 启动")]),a._v(" "),s("li",[a._v("停止：直接关闭启动的命令行窗口即可")])]),a._v(" "),s("h4",{attrs:{id:"linux-或-mac-os"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#linux-或-mac-os"}},[a._v("#")]),a._v(" Linux 或 Mac OS")]),a._v(" "),s("div",{staticClass:"language-bash line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 解压缩")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("unzip")]),a._v(" kafka-console-ui.zip\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 进入解压缩后的目录")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[a._v("cd")]),a._v(" kafka-console-ui\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 启动")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("sh")]),a._v(" bin/start.sh\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 停止")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("sh")]),a._v(" bin/shutdown.sh\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br")])]),s("h4",{attrs:{id:"访问地址"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#访问地址"}},[a._v("#")]),a._v(" 访问地址")]),a._v(" "),s("p",[a._v("启动完成，访问：http://127.0.0.1:7766")]),a._v(" "),s("h2",{attrs:{id:"kafka-如何保证消息不重复消费"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#kafka-如何保证消息不重复消费"}},[a._v("#")]),a._v(" Kafka 如何保证消息不重复消费？")]),a._v(" "),s("p",[s("strong",[a._v("kafka 出现消息重复消费的原因：")])]),a._v(" "),s("ul",[s("li",[a._v("服务端侧已经消费的数据没有成功提交 offset（根本原因）。")]),a._v(" "),s("li",[a._v("Kafka 侧 由于服务端处理业务时间长或者网络链接等等原因让 Kafka 认为服务假死，触发了分区 rebalance。")])]),a._v(" "),s("p",[s("strong",[a._v("解决方案：")])]),a._v(" "),s("ul",[s("li",[s("p",[a._v("消费消息服务做幂等校验，比如 Redis 的 set、MySQL 的主键等天然的幂等功能。这种方法最有效。")])]),a._v(" "),s("li",[s("p",[a._v("将 "),s("code",[a._v("enable.auto.commit")]),a._v(" 参数设置为 false，关闭自动提交，开发者在代码中手动提交 offset。")]),a._v(" "),s("p",[s("em",[a._v("那么这里会有个问题：什么时候提交 offset 合适？")])]),a._v(" "),s("ul",[s("li",[a._v("处理完消息再提交：依旧有消息重复消费的风险（例如提交前服务挂掉了），和自动提交一样。")]),a._v(" "),s("li",[a._v("拉取到消息即提交：会有消息丢失的风险。允许消息延时的场景，一般会采用这种方式。然后，通过定时任务在业务不繁忙（比如凌晨）的时候做数据兜底。")])])])]),a._v(" "),s("h3",{attrs:{id:"kafka-的自动提交是怎么样的"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#kafka-的自动提交是怎么样的"}},[a._v("#")]),a._v(" Kafka 的自动提交是怎么样的")]),a._v(" "),s("p",[a._v("Kafka 的自动提交（Automatic Offset Commit）是一种机制，用于确定 Kafka 消费者应该将其当前的消费位移（offset）提交到 Kafka 服务器。")]),a._v(" "),s("p",[a._v("消费位移是一个指示 Kafka 主题分区中消费者已读取到的位置的值。")]),a._v(" "),s("p",[a._v("自动提交可以帮助简化消费者的管理，但它也涉及一些注意事项和权衡。")]),a._v(" "),s("p",[s("em",[a._v("以下是关于 Kafka 自动提交的一些重要信息")]),a._v("：")]),a._v(" "),s("ol",[s("li",[s("p",[s("strong",[a._v("默认行为")]),a._v("：Kafka 消费者默认启用了自动提交。这意味着消费者会自动定期将当前的消费位移提交到 Kafka 服务器，而无需显式调用 "),s("code",[a._v("commitSync")]),a._v(" 或 "),s("code",[a._v("commitAsync")]),a._v(" 方法。")])]),a._v(" "),s("li",[s("p",[s("strong",[a._v("提交频率")]),a._v("：自动提交的频率由消费者配置参数 "),s("code",[a._v("auto.commit.interval.ms")]),a._v(" 决定，默认值为 5000 毫秒（5 秒）。这意味着每隔 5 秒，消费者将提交当前的位移。")])]),a._v(" "),s("li",[s("p",[s("strong",[a._v("幂等性问题")]),a._v("：自动提交可能导致幂等性问题。如果消息在处理过程中成功处理但在位移提交之前失败，那么消息可能会被重新处理，这可能导致副作用。为了解决这个问题，你可以采用幂等性的消息处理逻辑，或者使用手动位移提交来更精确地控制位移的提交时机。")])]),a._v(" "),s("li",[s("p",[s("strong",[a._v("配置禁用")]),a._v("：如果你希望完全控制位移的提交，可以禁用自动提交。通过将 "),s("code",[a._v("enable.auto.commit")]),a._v(" 配置为 "),s("code",[a._v("false")]),a._v("，你可以关闭自动提交功能，然后在适当的时候手动调用 "),s("code",[a._v("commitSync")]),a._v(" 或 "),s("code",[a._v("commitAsync")]),a._v(" 来提交位移。")]),a._v(" "),s("div",{staticClass:"language-properties line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-properties"}},[s("code",[s("span",{pre:!0,attrs:{class:"token key attr-name"}},[a._v("enable.auto.commit")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("=")]),s("span",{pre:!0,attrs:{class:"token value attr-value"}},[a._v("false")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br")])])]),a._v(" "),s("li",[s("p",[s("strong",[a._v("手动提交")]),a._v("：手动提交允许你在消息处理成功后显式地提交位移。这可以确保只有在消息成功处理后才提交位移，从而避免重复处理消息的问题。")]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[a._v("consumer"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("poll")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Duration")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("ofMillis")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("100")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 拉取消息")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 处理消息")]),a._v("\nconsumer"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("commitSync")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 手动提交位移")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br")])])])]),a._v(" "),s("p",[a._v("总之，自动提交是 Kafka 消费者的默认行为，但在一些情况下，特别是需要"),s("strong",[a._v("确保幂等性")]),a._v("和"),s("strong",[a._v("消息处理成功后才提交位移")]),a._v("的情况下，可能需要禁用自动提交并使用手动提交。自动提交的频率可以通过配置进行调整。")]),a._v(" "),s("h3",{attrs:{id:"讲讲-kafka-的自动提交-是在处理完消息前提交还是处理完消息之后提交"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#讲讲-kafka-的自动提交-是在处理完消息前提交还是处理完消息之后提交"}},[a._v("#")]),a._v(" 讲讲 kafka 的自动提交，是在处理完消息前提交还是处理完消息之后提交")]),a._v(" "),s("p",[a._v("Apache Kafka 的消费者有两种方式来提交消费的进度，也就是提交 offset，一种是自动提交，另一种是手动提交。")]),a._v(" "),s("p",[a._v("这里我们主要讨论自动提交。")]),a._v(" "),s("p",[a._v("在 Kafka 中，自动提交是指：消费者自动地定期提交已经拉取的消息的 offset。")]),a._v(" "),s("p",[a._v("如果启用了自动提交，那么 "),s("code",[a._v("auto.commit.interval.ms")]),a._v(" 配置的时间到了，消费者就会提交最新的 offset，无论消息是否已经处理完毕。")]),a._v(" "),s("p",[a._v("这意味着，自动提交的 offset 是在拉取到消息后就可能提交，而不一定是在处理完消息之后提交。这将导致在消费者崩溃或者重新启动时，可能会出现消息重复处理或者消息丢失的情况。")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("例如，如果消费者已经拉取了一些消息，但还没来得及处理，这时候自动提交触发，offset 被提交。如果此时消费者崩溃，再次启动时，它会从提交的 offset 开始消费，导致之前拉取但未处理的消息丢失。")])]),a._v(" "),s("li",[s("p",[a._v("另一方面，如果消费者拉取了一些消息并处理了它们，但在自动提交提交触发之前消费者崩溃了，那么 offset 并没有被提交。当消费者再次启动时，它会从上次提交的 offset 开始消费，这将导致处理过的消息被重复处理。")])])]),a._v(" "),s("p",[a._v("因此，")]),a._v(" "),s("ul",[s("li",[a._v("如果你的应用对消息的处理具有幂等性（即处理多次和处理一次的效果一样），那么使用自动提交可能是一个简单且有效的选择。")]),a._v(" "),s("li",[a._v("但如果你的应用需要精确地处理每一条消息，即不能丢失消息也不能重复处理消息，那么你可能需要考虑使用手动提交 offset，这样可以更精确地控制何时提交 offset。")])]),a._v(" "),s("h3",{attrs:{id:"自动提交与手动提交"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#自动提交与手动提交"}},[a._v("#")]),a._v(" 自动提交与手动提交")]),a._v(" "),s("ol",[s("li",[s("strong",[a._v("自动提交（Auto Commit）")]),a._v("：这是指 Kafka 消费者定期自动将当前已消费的消息位移（offset）提交到 Kafka 服务器，而无需显式的用户干预。自动提交的频率由配置参数控制，通常情况下是"),s("strong",[a._v("定期")]),a._v("的。这种提交位移的方式可能会导致一些消息"),s("em",[a._v("被处理但尚未确认已成功处理的情况")]),a._v("。如果发生故障，这些消息可能会被重新处理，从而可能导致消息的重复消费。")]),a._v(" "),s("li",[s("strong",[a._v("位移/手动 提交（Offset Commit）")]),a._v("：这是指消费者在成功处理一条消息后，显式地将该消息的位移提交到 Kafka 服务器。位移提交是由用户代码控制的，通常在处理逻辑执行后，确认消息已被成功处理后执行。这种提交位移的方式确保了消息只有在成功处理后才会被视为已消费，从而避免了消息的重复处理。")])]),a._v(" "),s("p",[a._v("一般来说，位移提交更可靠，因为它允许消费者完全控制位移何时提交，以确保消息被成功处理后才被标记为已消费。自动提交则更容易实现，但在某些情况下可能导致消息的重复消费，因此需要根据具体的需求和应用场景来选择使用哪种方式。")]),a._v(" "),s("p",[a._v("所以，自动提交是指消费者定期自动提交位移，而位移提交是指显式地提交位移，由用户代码控制。")]),a._v(" "),s("h2",{attrs:{id:"kafka-重试机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#kafka-重试机制"}},[a._v("#")]),a._v(" Kafka 重试机制")]),a._v(" "),s("h3",{attrs:{id:"消费失败会怎样"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#消费失败会怎样"}},[a._v("#")]),a._v(" 消费失败会怎样？")]),a._v(" "),s("p",[a._v("在默认配置下，当消费异常会进行重试，重试多次后会跳过当前消息，继续进行后续消息的消费，不会一直卡在当前消息。")]),a._v(" "),s("p",[a._v("因此，即使某个消息消费异常，Kafka 消费者仍然能够继续消费后续的消息，"),s("strong",[a._v("不会一直卡在当前消息")]),a._v("，保证了业务的正常进行。")]),a._v(" "),s("h3",{attrs:{id:"默认会重试多少次"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#默认会重试多少次"}},[a._v("#")]),a._v(" 默认会重试多少次？")]),a._v(" "),s("p",[a._v("Kafka 消费者在默认配置下会进行最多 "),s("strong",[a._v("10 次")]),a._v(" 的重试，每次重试的"),s("strong",[a._v("时间间隔为 0，即立即进行重试")]),a._v("。")]),a._v(" "),s("p",[a._v("如果在 10 次重试后仍然无法成功消费消息，则不再进行重试，消息将被视为消费失败。")]),a._v(" "),s("h3",{attrs:{id:"如何在重试失败后进行告警"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何在重试失败后进行告警"}},[a._v("#")]),a._v(" 如何在重试失败后进行告警？")]),a._v(" "),s("p",[a._v("自定义重试失败后逻辑，需要手动实现，可以通过【重写 "),s("code",[a._v("DefaultErrorHandler")]),a._v(" 的 "),s("code",[a._v("handleRemaining")]),a._v(" 函数，加上自定义的告警等操作来】实现。")]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[a._v("@Slf4j")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("DelErrorHandler")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("extends")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("DefaultErrorHandler")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("DelErrorHandler")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("FixedBackOff")]),a._v(" backOff"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("super")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("backOff"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[a._v("@Override")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("handleRemaining")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Exception")]),a._v(" thrownException"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("List")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("ConsumerRecord")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("?")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("?")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v(" records"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Consumer")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("?")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("?")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),a._v(" consumer"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("MessageListenerContainer")]),a._v(" container"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("super")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("handleRemaining")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("thrownException"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" records"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" consumer"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" container"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n        log"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("info")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"重试多次失败"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 自定义操作")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br"),s("span",{staticClass:"line-number"},[a._v("12")]),s("br"),s("span",{staticClass:"line-number"},[a._v("13")]),s("br"),s("span",{staticClass:"line-number"},[a._v("14")]),s("br")])]),s("p",[s("code",[a._v("DefaultErrorHandler")]),a._v(" 只是默认的一个错误处理器，Spring Kafka 还提供了 "),s("code",[a._v("CommonErrorHandler")]),a._v(" 接口。手动实现 "),s("code",[a._v("CommonErrorHandler")]),a._v(" 就可以实现更多的自定义操作，有很高的灵活性。例如根据不同的错误类型，实现不同的重试逻辑以及业务逻辑等。")]),a._v(" "),s("h3",{attrs:{id:"重试失败后的数据如何再次处理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#重试失败后的数据如何再次处理"}},[a._v("#")]),a._v(" 重试失败后的数据如何再次处理？")]),a._v(" "),s("p",[s("em",[a._v("当达到最大重试次数后，数据会直接被跳过，继续向后进行。当代码修复后，如何重新消费这些重试失败的数据呢？")])]),a._v(" "),s("p",[a._v("当达到最大重试次数后，如果仍然无法成功处理消息，消息会被发送到对应的死信队列中。对于死信队列的处理，既可以用 "),s("code",[a._v("@DltHandler")]),a._v(" 处理，也可以使用 "),s("code",[a._v("@KafkaListener")]),a._v(" 重新消费。")]),a._v(" "),s("h3",{attrs:{id:"重试注解-retryabletopic"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#重试注解-retryabletopic"}},[a._v("#")]),a._v(" 重试注解 @RetryableTopic")]),a._v(" "),s("p",[s("code",[a._v("@RetryableTopic")]),a._v(" 是 Spring Kafka 中的一个注解，它用于配置某个 Topic 支持消息重试，更推荐使用这个注解来完成重试。")]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 重试 5 次，重试间隔 100 毫秒,最大间隔 1 秒")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[a._v("@RetryableTopic")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("\n        attempts "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"5"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("\n        backoff "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[a._v("@Backoff")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("delay "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("100")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" maxDelay "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1000")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[a._v("@KafkaListener")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("topics "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("KafkaConst")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token constant"}},[a._v("TEST_TOPIC")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" groupId "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"apple"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("customer")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),a._v(" message"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    log"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("info")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[a._v('"kafka customer:{}"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" message"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Integer")]),a._v(" n "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Integer")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("parseInt")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("message"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("n "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("%")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("5")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("==")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("throw")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("RuntimeException")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("System")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("out"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("println")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br"),s("span",{staticClass:"line-number"},[a._v("12")]),s("br"),s("span",{staticClass:"line-number"},[a._v("13")]),s("br"),s("span",{staticClass:"line-number"},[a._v("14")]),s("br")])]),s("h3",{attrs:{id:"什么是死信队列"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是死信队列"}},[a._v("#")]),a._v(" 什么是死信队列？")]),a._v(" "),s("p",[a._v('**死信队列（Dead Letter Queue，简称 DLQ）**是消息中间件中的一种特殊队列。它主要用于处理无法被消费者正确处理的消息，通常是因为消息格式错误、处理失败、消费超时等情况导致的消息被"丢弃"或"死亡"的情况。')]),a._v(" "),s("ul",[s("li",[a._v("当消息进入队列后，消费者会尝试处理它。如果处理失败，或者超过一定的重试次数仍无法被成功处理，消息可以发送到死信队列中，而不是被永久性地丢弃。")]),a._v(" "),s("li",[a._v("在死信队列中，可以进一步分析、处理这些无法正常消费的消息，以便定位问题、修复错误，并采取适当的措施。")])]),a._v(" "),s("h2",{attrs:{id:"kafka-工作原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#kafka-工作原理"}},[a._v("#")]),a._v(" Kafka 工作原理")]),a._v(" "),s("h3",{attrs:{id:"生产"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#生产"}},[a._v("#")]),a._v(" 生产")]),a._v(" "),s("p",[a._v("消息经过序列化后，通过不同的分区策略，找到对应的分区。")]),a._v(" "),s("p",[s("strong",[a._v("相同主题和分区的消息，会被存放在同一个批次里")]),a._v("，然后由一个独立的线程负责把它们发到 Kafka Broker 上。")]),a._v(" "),s("p",[s("em",[a._v("分区的策略包括顺序轮询、随机轮询和 key hash 这 3 种方式，那什么是分区呢？")])]),a._v(" "),s("p",[a._v("分区是 Kafka 读写数据的最小粒度，比如主题 A 有 15 条消息，有 5 个分区，如果采用顺序轮询的方式，15 条消息会顺序分配给这 5 个分区，后续消费的时候，也是按照分区粒度消费。")]),a._v(" "),s("p",[a._v("由于分区可以部署在多个不同的机器上，所以可以通过分区实现 Kafka 的伸缩性，比如主题 A 的 5 个分区，分别部署在 5 台机器上，如果下线一台，分区就变为 4。")]),a._v(" "),s("h3",{attrs:{id:"消费"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#消费"}},[a._v("#")]),a._v(" 消费")]),a._v(" "),s("ul",[s("li",[a._v("Kafka 消费是通过消费群组完成，【同一个】消费者群组，"),s("strong",[a._v("一个消费者可以消费多个【分区】，但是一个【分区】，只能被一个消费者消费。")])]),a._v(" "),s("li",[s("strong",[a._v("如果消费者增加，会触发 Rebalance，也就是分区和消费者需要重新配对")]),a._v("。")]),a._v(" "),s("li",[s("strong",[a._v("不同的消费群组互不干涉")]),a._v("。")])]),a._v(" "),s("h2",{attrs:{id:"ack-参数"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ack-参数"}},[a._v("#")]),a._v(" ack 参数")]),a._v(" "),s("p",[s("code",[a._v("required-acks")]),a._v(" 是 Kafka "),s("strong",[a._v("生产者配置")]),a._v("的一个参数，它定义了生产者等待确认消息已被接收的策略。")]),a._v(" "),s("p",[s("code",[a._v("required-acks")]),a._v(" 的值可以是：")]),a._v(" "),s("ul",[s("li",[s("code",[a._v("0")]),a._v("：生产者不需要等待任何确认，一旦消息被发送到 leader broker 就会返回成功。这是最快速但最不保证的消息传递。")]),a._v(" "),s("li",[s("code",[a._v("1")]),a._v("（默认）：生产者等待 leader broker 确认收到消息。这是通常推荐的设置，因为它提供了单个副本的消息持久化保证。")]),a._v(" "),s("li",[s("code",[a._v("-1")]),a._v(" 或 "),s("code",[a._v("all")]),a._v("：生产者不仅等待 leader broker 的确认，还等待所有 ISR（In-Sync Replicas）的确认。这是最安全但最慢的设置。")])]),a._v(" "),s("h2",{attrs:{id:"学习参考"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#学习参考"}},[a._v("#")]),a._v(" 学习参考")]),a._v(" "),s("ul",[s("li",[s("a",{attrs:{href:"https://javaguide.cn/high-performance/message-queue/kafka-questions-01.html#kafka-%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6",target:"_blank",rel:"noopener noreferrer"}},[a._v("Kafka常见问题总结 | JavaGuide(Java面试 + 学习指南)"),s("OutboundLink")],1)]),a._v(" "),s("li",[s("a",{attrs:{href:"https://mp.weixin.qq.com/s/pgrx0S7gxMpcgzhP6dVvFQ",target:"_blank",rel:"noopener noreferrer"}},[a._v("4 种消息队列，如何选型？ (qq.com)"),s("OutboundLink")],1)]),a._v(" "),s("li",[s("a",{attrs:{href:"https://blog.csdn.net/m0_37501154/article/details/104849035",target:"_blank",rel:"noopener noreferrer"}},[a._v("Kafka的ACK参数-1,0,1分别代表什么含义，如何保证宕机的时候数据不丢失的_kafka ack 0 1 -1-CSDN博客"),s("OutboundLink")],1)])])])}),[],!1,null,null,null);s.default=e.exports}}]);