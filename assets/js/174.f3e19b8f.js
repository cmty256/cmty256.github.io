(window.webpackJsonp=window.webpackJsonp||[]).push([[174],{519:function(t,v,e){"use strict";e.r(v);var a=e(1),_=Object(a.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"netty-入门"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#netty-入门"}},[t._v("#")]),t._v(" Netty 入门")]),t._v(" "),v("h2",{attrs:{id:"什么是-netty"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是-netty"}},[t._v("#")]),t._v(" 什么是 Netty？")]),t._v(" "),v("p",[v("strong",[t._v("Netty 是基于 Java NIO 封装的高性能、异步事件驱动的网络通信框架")]),t._v("，用于开发 TCP、UDP、HTTP 等网络协议的客户端和服务端程序。")]),t._v(" "),v("ul",[v("li",[v("strong",[v("a",{attrs:{href:"https://cmty256.github.io/pages/40a120/#nio-non-blocking-new-i-o",target:"_blank",rel:"noopener noreferrer"}},[t._v("NIO"),v("OutboundLink")],1)]),t._v("：同步非阻塞 IO 模型")])]),t._v(" "),v("h2",{attrs:{id:"netty-的核心理念和原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#netty-的核心理念和原理"}},[t._v("#")]),t._v(" Netty 的核心理念和原理")]),t._v(" "),v("p",[t._v("Netty 核心基于 "),v("strong",[t._v("Reactor 模式 + NIO 非阻塞 I/O")]),t._v("，实现了高并发、低延迟的通信机制。")]),t._v(" "),v("p",[v("strong",[t._v("核心组件")]),t._v("：")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("组件")]),t._v(" "),v("th",[t._v("作用")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[v("code",[t._v("EventLoopGroup")])]),t._v(" "),v("td",[t._v("事件循环线程池，负责处理连接、读写等操作")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("Channel")])]),t._v(" "),v("td",[t._v("抽象的网络连接通道")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("ChannelPipeline")])]),t._v(" "),v("td",[t._v("责任链，保存 ChannelHandler 的执行链")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("ChannelHandler")])]),t._v(" "),v("td",[t._v("业务逻辑处理器，处理读写事件")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("ByteBuf")])]),t._v(" "),v("td",[t._v("Netty 自定义的缓冲区，替代 ByteBuffer，使用灵活高效")])])])]),t._v(" "),v("h2",{attrs:{id:"netty-的机制-通信流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#netty-的机制-通信流程"}},[t._v("#")]),t._v(" Netty 的机制（通信流程）")]),t._v(" "),v("p",[t._v("下面是 Netty 服务端的典型工作机制：")]),t._v(" "),v("div",{staticClass:"language-text line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("1. 客户端连接 -> BossGroup 线程接收连接\n2. 将连接注册到 WorkerGroup 的 EventLoop\n3. EventLoop 负责读写事件处理（使用 Selector 监听）\n4. 收到数据 -> 解码 -> 业务逻辑处理 -> 编码 -> 写回客户端\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br"),v("span",{staticClass:"line-number"},[t._v("3")]),v("br"),v("span",{staticClass:"line-number"},[t._v("4")]),v("br")])]),v("p",[t._v("多路复用：")]),t._v(" "),v("ul",[v("li",[t._v("基于 Java NIO 的 "),v("code",[t._v("Selector")]),t._v("，使用一个线程监听多个 Channel，提高资源利用率。")])]),t._v(" "),v("h2",{attrs:{id:"netty-的线程模型-reactor"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#netty-的线程模型-reactor"}},[t._v("#")]),t._v(" Netty 的线程模型（Reactor）")]),t._v(" "),v("p",[t._v("支持三种模式：")]),t._v(" "),v("ul",[v("li",[t._v("在生产中常用 "),v("strong",[t._v("多线程 Reactor 模式（BossGroup + WorkerGroup）")])])]),t._v(" "),v("ol",[v("li",[v("strong",[t._v("单 Reactor 单线程")]),t._v(" "),v("ul",[v("li",[t._v("所有操作都在一个线程中完成")]),t._v(" "),v("li",[t._v("适合轻量级服务，性能瓶颈明显")])])]),t._v(" "),v("li",[v("strong",[t._v("单 Reactor 多线程")]),t._v(" "),v("ul",[v("li",[t._v("Reactor 线程负责监听和分发事件")]),t._v(" "),v("li",[t._v("具体业务逻辑交给线程池执行")])])]),t._v(" "),v("li",[v("strong",[t._v("多 Reactor 多线程")]),t._v("（默认）\n"),v("ul",[v("li",[t._v("多个 Reactor 线程各自管理一组 Channel")]),t._v(" "),v("li",[t._v("主 Reactor 接收连接后分配给子 Reactor")]),t._v(" "),v("li",[t._v("Netty 默认使用的是这种模型")])])])]),t._v(" "),v("h2",{attrs:{id:"netty-的优势"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#netty-的优势"}},[t._v("#")]),t._v(" Netty 的优势")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("优势")]),t._v(" "),v("th",[t._v("说明")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("高性能")]),t._v(" "),v("td",[t._v("零拷贝、池化 ByteBuf、异步 I/O")])]),t._v(" "),v("tr",[v("td",[t._v("灵活")]),t._v(" "),v("td",[t._v("可定制协议、编解码、事件处理")])]),t._v(" "),v("tr",[v("td",[t._v("稳定成熟")]),t._v(" "),v("td",[t._v("Dubbo、RocketMQ、Elasticsearch 等底层使用")])]),t._v(" "),v("tr",[v("td",[t._v("社区活跃")]),t._v(" "),v("td",[t._v("提供丰富示例和文档，更新稳定")])])])]),t._v(" "),v("p",[t._v("ByteBuf 的优势：")]),t._v(" "),v("ul",[v("li",[t._v("支持动态扩容、读写指针分离")]),t._v(" "),v("li",[t._v("池化管理，减少内存分配/GC")]),t._v(" "),v("li",[t._v("使用内存更高效（比 "),v("code",[t._v("ByteBuffer")]),t._v(" 更强）")])]),t._v(" "),v("p",[t._v("虽然 Netty 是基于 NIO 实现的，但它解决了原生 NIO 的一些痛点：")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("原生 NIO 的问题")]),t._v(" "),v("th",[t._v("Netty 的解决方案")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("使用复杂，API 不友好")]),t._v(" "),v("td",[t._v("提供简单易用的 API")])]),t._v(" "),v("tr",[v("td",[t._v("处理空轮询 bug")]),t._v(" "),v("td",[t._v("内部优化避免该问题")])]),t._v(" "),v("tr",[v("td",[t._v("没有内置的线程模型")]),t._v(" "),v("td",[t._v("提供完善的线程模型（EventLoopGroup）")])]),t._v(" "),v("tr",[v("td",[t._v("没有编解码器支持")]),t._v(" "),v("td",[t._v("提供丰富的编解码器库")])]),t._v(" "),v("tr",[v("td",[t._v("没有良好的异常处理机制")]),t._v(" "),v("td",[t._v("提供统一的异常捕获和处理机制")])])])]),t._v(" "),v("h2",{attrs:{id:"netty-在项目中的常见应用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#netty-在项目中的常见应用"}},[t._v("#")]),t._v(" Netty 在项目中的常见应用")]),t._v(" "),v("ol",[v("li",[v("strong",[t._v("RPC 框架底层通信组件")]),t._v("（如 Dubbo 使用 Netty 实现网络通信）")]),t._v(" "),v("li",[v("strong",[t._v("高并发聊天系统、IM、游戏服务端")])]),t._v(" "),v("li",[v("strong",[t._v("MQ 消息队列传输模块")]),t._v("（如 RocketMQ）")]),t._v(" "),v("li",[v("strong",[t._v("自定义协议服务")]),t._v("（如设备物联网通信协议解析）")])]),t._v(" "),v("h2",{attrs:{id:"编码解码机制-编解码器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#编码解码机制-编解码器"}},[t._v("#")]),t._v(" 编码解码机制（编解码器）")]),t._v(" "),v("p",[t._v("通过 "),v("code",[t._v("ChannelHandler")]),t._v(" 中的 "),v("code",[t._v("Decoder")]),t._v(" 和 "),v("code",[t._v("Encoder")]),t._v(" 实现协议编解码。")]),t._v(" "),v("p",[t._v("常用的编解码器有：")]),t._v(" "),v("ul",[v("li",[v("code",[t._v("LineBasedFrameDecoder")]),t._v("：按行切分")]),t._v(" "),v("li",[v("code",[t._v("LengthFieldBasedFrameDecoder")]),t._v("：按消息长度切分")]),t._v(" "),v("li",[v("code",[t._v("StringDecoder")]),t._v("、"),v("code",[t._v("ProtobufDecoder")]),t._v("、"),v("code",[t._v("HttpObjectDecoder")])])]),t._v(" "),v("p",[t._v("可用于定制自己的协议，例如：")]),t._v(" "),v("div",{staticClass:"language-java line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-java"}},[v("code",[t._v("pipeline"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),v("span",{pre:!0,attrs:{class:"token function"}},[t._v("addLast")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("LengthFieldBasedFrameDecoder")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\npipeline"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),v("span",{pre:!0,attrs:{class:"token function"}},[t._v("addLast")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("CustomMessageDecoder")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\npipeline"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),v("span",{pre:!0,attrs:{class:"token function"}},[t._v("addLast")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("BusinessLogicHandler")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br"),v("span",{staticClass:"line-number"},[t._v("3")]),v("br")])]),v("h2",{attrs:{id:"netty-如何实现高性能-细节"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#netty-如何实现高性能-细节"}},[t._v("#")]),t._v(" Netty 如何实现高性能（细节）")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("技术点")]),t._v(" "),v("th",[t._v("作用")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("零拷贝（Zero-Copy）")]),t._v(" "),v("td",[t._v("避免内核态和用户态之间的数据复制")])]),t._v(" "),v("tr",[v("td",[t._v("对象复用")]),t._v(" "),v("td",[t._v("使用对象池（如 Recycler）减少频繁创建销毁")])]),t._v(" "),v("tr",[v("td",[t._v("异步非阻塞")]),t._v(" "),v("td",[t._v("所有 I/O 操作都基于 Selector 异步处理")])]),t._v(" "),v("tr",[v("td",[t._v("事件驱动")]),t._v(" "),v("td",[t._v("所有操作都是事件驱动机制，避免阻塞线程")])])])]),t._v(" "),v("p",[t._v("同步 vs 异步 的关键区别：")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("同步（Synchronous）")]),t._v("：应用程序必须自己去获取数据或等待 I/O 完成。")]),t._v(" "),v("li",[v("strong",[t._v("异步（Asynchronous）")]),t._v("：系统完成后自动通知应用程序，应用程序不需要主动去取。")])]),t._v(" "),v("h2",{attrs:{id:"总结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),v("p",[t._v("Netty 是基于 NIO 的高性能网络框架，封装了复杂的底层通信细节，支持异步、事件驱动、零拷贝、线程复用等机制，广泛用于 RPC、MQ、IM 等高并发系统，是构建网络通信服务的首选框架。")]),t._v(" "),v("p",[v("strong",[t._v("总结对比表：")])]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("技术")]),t._v(" "),v("th",[t._v("类型")]),t._v(" "),v("th",[t._v("说明")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[v("code",[t._v("Selector")])]),t._v(" "),v("td",[t._v("Java NIO API")]),t._v(" "),v("td",[t._v("实现 I/O 多路复用的基础组件")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("Reactor")])]),t._v(" "),v("td",[t._v("设计模式")]),t._v(" "),v("td",[t._v("基于 Selector 构建的事件驱动模型")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("NIO 线程模型")])]),t._v(" "),v("td",[t._v("编程模型")]),t._v(" "),v("td",[t._v("利用 Reactor 模式构建高性能服务器")])]),t._v(" "),v("tr",[v("td",[v("code",[t._v("Netty")])]),t._v(" "),v("td",[t._v("框架")]),t._v(" "),v("td",[t._v("封装了 Reactor 模式，提供异步非阻塞风格的 API")])])])]),t._v(" "),v("h2",{attrs:{id:"附录"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#附录"}},[t._v("#")]),t._v(" 附录")]),t._v(" "),v("h3",{attrs:{id:"selector-是什么"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#selector-是什么"}},[t._v("#")]),t._v(" Selector 是什么？")]),t._v(" "),v("h4",{attrs:{id:"定义"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#定义"}},[t._v("#")]),t._v(" 定义")]),t._v(" "),v("p",[v("code",[t._v("Selector")]),t._v(" 是 Java NIO 中的一个组件，它允许一个线程可以监视多个 "),v("code",[t._v("Channel")]),t._v("（如 Socket）的 I/O 状态变化（例如：连接、读就绪、写就绪等），是实现 "),v("strong",[t._v("I/O 多路复用（Multiplexing）")]),t._v(" 的核心机制。")]),t._v(" "),v("h4",{attrs:{id:"作用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#作用"}},[t._v("#")]),t._v(" 作用")]),t._v(" "),v("ul",[v("li",[t._v("监听多个 Channel 的事件（如 OP_READ、OP_WRITE、OP_ACCEPT）")]),t._v(" "),v("li",[t._v("避免为每个连接创建一个线程（节省资源）")]),t._v(" "),v("li",[t._v("实现高效的 I/O 操作（适用于高并发）")])]),t._v(" "),v("h3",{attrs:{id:"reactor-是什么"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#reactor-是什么"}},[t._v("#")]),t._v(" Reactor 是什么？")]),t._v(" "),v("h4",{attrs:{id:"定义-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#定义-2"}},[t._v("#")]),t._v(" 定义")]),t._v(" "),v("p",[v("code",[t._v("Reactor")]),t._v(" 是一种设计模式，用于处理多个客户端请求，通常基于 "),v("strong",[t._v("I/O 多路复用模型")]),t._v(" （比如 "),v("code",[t._v("Selector")]),t._v("）。它是一种 "),v("strong",[t._v("事件驱动（Event-driven）")]),t._v(" 的架构模式，广泛应用于服务器端网络编程中。")]),t._v(" "),v("h4",{attrs:{id:"核心思想"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#核心思想"}},[t._v("#")]),t._v(" 核心思想")]),t._v(" "),v("p",[t._v("使用一个或多个线程来监听和分发事件，将不同的 I/O 事件（如 accept、read、write）分发给相应的处理器进行处理。")]),t._v(" "),v("h4",{attrs:{id:"角色"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#角色"}},[t._v("#")]),t._v(" 角色")]),t._v(" "),v("p",[t._v("典型的 Reactor 模式包含以下角色：")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("组件")]),t._v(" "),v("th",[t._v("职责")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[v("strong",[t._v("Reactor")])]),t._v(" "),v("td",[t._v("负责监听和分发事件（相当于主循环 + Selector）")])]),t._v(" "),v("tr",[v("td",[v("strong",[t._v("Acceptor")])]),t._v(" "),v("td",[t._v("当有新连接到达时，负责处理 accept 事件并创建新的 Channel")])]),t._v(" "),v("tr",[v("td",[v("strong",[t._v("Handler")])]),t._v(" "),v("td",[t._v("处理具体的 I/O 事件（如 read/write）")])])])])])}),[],!1,null,null,null);v.default=_.exports}}]);