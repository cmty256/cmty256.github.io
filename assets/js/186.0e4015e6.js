(window.webpackJsonp=window.webpackJsonp||[]).push([[186],{515:function(t,a,s){"use strict";s.r(a);var n=s(1),r=Object(n.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"kafka-实现顺序消费"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#kafka-实现顺序消费"}},[t._v("#")]),t._v(" Kafka 实现顺序消费")]),t._v(" "),a("h2",{attrs:{id:"kafka-默认的顺序保证机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#kafka-默认的顺序保证机制"}},[t._v("#")]),t._v(" Kafka 默认的顺序保证机制")]),t._v(" "),a("p",[a("strong",[t._v("Kafka 默认只能保证")]),t._v("：")]),t._v(" "),a("ul",[a("li",[t._v("在同一个 Partition 中，消息是按照生产顺序被消费的（即 "),a("strong",[t._v("单 Partition 顺序")]),t._v("）。")])]),t._v(" "),a("p",[a("strong",[t._v("示例说明")]),t._v("：")]),t._v(" "),a("ul",[a("li",[t._v("如果 Topic 有多个 Partition，Kafka 会将消息打散到不同 Partition，消费时多个线程并发拉取，"),a("strong",[t._v("无法保证整体顺序")]),t._v("。")]),t._v(" "),a("li",[t._v("若你对顺序有要求，必须：\n"),a("ul",[a("li",[t._v("让"),a("strong",[t._v("同一类消息始终进入同一个 Partition")])]),t._v(" "),a("li",[a("strong",[t._v("一个 Partition 内串行消费")])])])])]),t._v(" "),a("h2",{attrs:{id:"kafka-实现顺序消费的关键条件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#kafka-实现顺序消费的关键条件"}},[t._v("#")]),t._v(" Kafka 实现顺序消费的关键条件")]),t._v(" "),a("h3",{attrs:{id:"_1-同一类消息进入同一个-partition-关键"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-同一类消息进入同一个-partition-关键"}},[t._v("#")]),t._v(" 1. 同一类消息进入同一个 Partition（关键）")]),t._v(" "),a("ul",[a("li",[t._v("Kafka 分区是按照 key 进行 hash 分配的")]),t._v(" "),a("li",[t._v("所以只要 key 相同，Kafka 就会将消息写入同一个 Partition，从而保证顺序性。")])]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[t._v("producer"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("send")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ProducerRecord")]),a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"topic"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"sameKey"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" value"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("h3",{attrs:{id:"_2-消费端设置为单线程消费-partition-串行"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-消费端设置为单线程消费-partition-串行"}},[t._v("#")]),t._v(" 2. 消费端设置为"),a("strong",[t._v("单线程")]),t._v("消费 Partition（串行）")]),t._v(" "),a("ul",[a("li",[t._v("Kafka 每个 Partition 默认只能被"),a("strong",[t._v("一个 Consumer 实例线程消费")]),t._v("。")]),t._v(" "),a("li",[t._v("若你使用线程池或并发处理 Partition 消息，要确保"),a("strong",[t._v("消费同一个 Partition 的线程是单一的")]),t._v("。")])]),t._v(" "),a("h3",{attrs:{id:"_3-分区数-消费线程数-或-消费实例数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-分区数-消费线程数-或-消费实例数"}},[t._v("#")]),t._v(" 3. 分区数 = 消费线程数（或 = 消费实例数）")]),t._v(" "),a("ul",[a("li",[t._v("如果你有顺序消费的需求，"),a("strong",[t._v("不能启用多个消费者消费同一个 Partition")]),t._v("，否则顺序就被打破。")])]),t._v(" "),a("h2",{attrs:{id:"典型顺序消费场景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#典型顺序消费场景"}},[t._v("#")]),t._v(" 典型顺序消费场景")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("场景")]),t._v(" "),a("th",[t._v("说明")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("订单状态流转")]),t._v(" "),a("td",[t._v("下单 → 支付 → 发货 → 收货，必须顺序处理")])]),t._v(" "),a("tr",[a("td",[t._v("财务入账流水")]),t._v(" "),a("td",[t._v("金额变更必须按时间严格入账")])]),t._v(" "),a("tr",[a("td",[t._v("用户行为日志")]),t._v(" "),a("td",[t._v("记录顺序操作行为用于分析")])])])]),t._v(" "),a("h2",{attrs:{id:"顺序消费的-kafka-设计实践"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#顺序消费的-kafka-设计实践"}},[t._v("#")]),t._v(" 顺序消费的 Kafka 设计实践")]),t._v(" "),a("h3",{attrs:{id:"producer-端"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#producer-端"}},[t._v("#")]),t._v(" Producer 端")]),t._v(" "),a("ul",[a("li",[t._v("使用相同 key 保证同类消息写入同一 Partition：")])]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 订单 ID 作为 key")]),t._v("\nproducer"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("send")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ProducerRecord")]),a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v('"order_topic"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" orderId"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" orderEvent"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br")])]),a("h3",{attrs:{id:"consumer-端"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#consumer-端"}},[t._v("#")]),t._v(" Consumer 端")]),t._v(" "),a("ul",[a("li",[t._v("保证 Partition 消费是"),a("strong",[t._v("单线程串行处理")]),t._v("，例如：")])]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 使用 Kafka 原生 Consumer，按 Partition 消费")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ConsumerRecord")]),a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" record "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" records"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("partitions")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 按 partition 拆分，再逐条处理")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br")])]),a("ul",[a("li",[t._v("或使用 Spring Kafka 设置并发数匹配分区数：")])]),t._v(" "),a("div",{staticClass:"language-yaml line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-yaml"}},[a("code",[a("span",{pre:!0,attrs:{class:"token key atrule"}},[t._v("spring.kafka.listener.concurrency")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),t._v("  "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 设置并发数，必须与 partition 数量一致")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("h2",{attrs:{id:"常见错误-顺序失效点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常见错误-顺序失效点"}},[t._v("#")]),t._v(" 常见错误 & 顺序失效点")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("错误点")]),t._v(" "),a("th",[t._v("后果")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("同类消息 key 不一致")]),t._v(" "),a("td",[t._v("会打散到多个 Partition，顺序错乱")])]),t._v(" "),a("tr",[a("td",[t._v("Partition 被多个线程消费")]),t._v(" "),a("td",[t._v("并发处理导致乱序")])]),t._v(" "),a("tr",[a("td",[t._v("自动负载均衡导致 rebalance")]),t._v(" "),a("td",[t._v("Consumer Group rebalance 时可能打乱顺序")])]),t._v(" "),a("tr",[a("td",[t._v("异步处理消息逻辑")]),t._v(" "),a("td",[t._v("异步操作返回无序")])])])]),t._v(" "),a("h2",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),a("p",[t._v("Kafka 默认支持"),a("strong",[t._v("Partition 内的顺序性")]),t._v("。要实现顺序消费，需要将"),a("strong",[t._v("相同业务标识的消息（如订单号）投递到同一个 Partition")]),t._v("，并且确保"),a("strong",[t._v("消费端对 Partition 的消息是单线程串行处理的")]),t._v("。")])])}),[],!1,null,null,null);a.default=r.exports}}]);