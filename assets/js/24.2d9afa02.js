(window.webpackJsonp=window.webpackJsonp||[]).push([[24],{352:function(t,s,a){"use strict";a.r(s);var v=a(1),_=Object(v.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"锁详解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#锁详解"}},[t._v("#")]),t._v(" 锁详解")]),t._v(" "),s("h2",{attrs:{id:"死锁问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#死锁问题"}},[t._v("#")]),t._v(" 死锁问题")]),t._v(" "),s("h3",{attrs:{id:"什么是线程死锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是线程死锁"}},[t._v("#")]),t._v(" 什么是线程死锁?")]),t._v(" "),s("p",[t._v("线程死锁是指：两个或多个线程互相持有对方所需要的资源而互相等待的状态，导致程序无法继续执行下去，进而陷入死循环，无法完成任务。")]),t._v(" "),s("h3",{attrs:{id:"死锁产生的原因"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#死锁产生的原因"}},[t._v("#")]),t._v(" 死锁产生的原因")]),t._v(" "),s("p",[t._v("通常情况下，线程死锁产生的原因是: "),s("strong",[t._v("两个或多个线程对资源的竞争和不当的资源分配")]),t._v("。")]),t._v(" "),s("h3",{attrs:{id:"死锁产生的条件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#死锁产生的条件"}},[t._v("#")]),t._v(" 死锁产生的条件")]),t._v(" "),s("p",[t._v("线程死锁的产生通常需要"),s("strong",[t._v("同时满足以下四个条件")]),t._v("：")]),t._v(" "),s("ol",[s("li",[s("strong",[t._v("互斥条件")]),t._v("：该资源任意一个时刻只由一个线程占用。")]),t._v(" "),s("li",[s("strong",[t._v("请求与保持条件")]),t._v("：一个线程因请求资源而阻塞时，对已获得的资源保持不放。")]),t._v(" "),s("li",[s("strong",[t._v("不剥夺条件")]),t._v("：线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。")]),t._v(" "),s("li",[s("strong",[t._v("循环等待条件")]),t._v(": 若干线程之间形成一种头尾相接的循环等待资源关系。")])]),t._v(" "),s("h3",{attrs:{id:"如何预防死锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何预防死锁"}},[t._v("#")]),t._v(" 如何预防死锁？")]),t._v(" "),s("p",[t._v("预防死锁只要破坏死锁产生的必要条件即可：")]),t._v(" "),s("ol",[s("li",[s("strong",[t._v("破坏请求与保持条件")]),t._v("：一次性申请所有的资源。")]),t._v(" "),s("li",[s("strong",[t._v("破坏不剥夺条件")]),t._v("：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。")]),t._v(" "),s("li",[s("strong",[t._v("破坏循环等待条件")]),t._v("：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。")])]),t._v(" "),s("h3",{attrs:{id:"如何避免死锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何避免死锁"}},[t._v("#")]),t._v(" 如何避免死锁？")]),t._v(" "),s("p",[t._v("避免死锁就是"),s("strong",[t._v("在资源分配时，借助于算法（比如银行家算法）对资源分配进行计算评估，使其进入安全状态")]),t._v("。")]),t._v(" "),s("h2",{attrs:{id:"乐观锁和悲观锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#乐观锁和悲观锁"}},[t._v("#")]),t._v(" 乐观锁和悲观锁")]),t._v(" "),s("p",[s("strong",[t._v("乐观锁和悲观锁")]),t._v("是并发编程中非常重要的两种并发控制策略，在数据库和 Java 应用中都非常常见。")]),t._v(" "),s("h3",{attrs:{id:"什么是乐观锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是乐观锁"}},[t._v("#")]),t._v(" 什么是乐观锁？")]),t._v(" "),s("p",[t._v("乐观锁总是假设最好的情况，"),s("strong",[t._v("认为共享资源每次被访问的时候不会出现问题")]),t._v("，线程可以不停地执行，"),s("strong",[t._v("无需加锁也无需等待")]),t._v("，只是在提交修改的时候去验证对应的资源是否被其它线程修改了。")]),t._v(" "),s("p",[s("strong",[t._v("定义")])]),t._v(" "),s("p",[t._v("乐观锁认为并发修改是小概率事件，每次修改前不加锁，而是在更新时检查是否有别的线程/事务更新过。")]),t._v(" "),s("p",[s("em",[s("strong",[t._v("特点")])])]),t._v(" "),s("ul",[s("li",[t._v("非阻塞，不会造成线程阻塞（"),s("strong",[t._v("优点")]),t._v("）")]),t._v(" "),s("li",[t._v("更适合读多写少的场景")]),t._v(" "),s("li",[t._v("冲突时通过重试机制来保障正确性")])]),t._v(" "),s("p",[s("em",[s("strong",[t._v("缺点")])])]),t._v(" "),s("ul",[s("li",[t._v("在并发更新的情况下，可能会出现 ABA 问题，需要使用版本号或时间戳等机制来解决。")])]),t._v(" "),s("blockquote",[s("p",[t._v("ABA 问题是: 在使用 CAS 算法时可能出现的一个问题。")]),t._v(" "),s("p",[t._v("它的本质是: 由于线程之间的竞争，导致共享数据的值在某个时间点被修改为 A，然后又被修改为 B，最后再被修改回 A，")]),t._v(" "),s("p",[t._v("这时候使用 CAS 算法时，比较的是共享数据的值是否等于 A，如果等于 A，则执行操作，但"),s("strong",[t._v("实际上共享数据的值已经被修改过了")]),t._v("。")]),t._v(" "),s("p",[t._v("简单来说，就是在使用 CAS 算法的时候发生了误判。")])]),t._v(" "),s("p",[s("em",[s("strong",[t._v("典型代表")])])]),t._v(" "),s("p",[t._v("比如：使用版本号机制、CAS 算法")]),t._v(" "),s("h3",{attrs:{id:"什么是悲观锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是悲观锁"}},[t._v("#")]),t._v(" 什么是悲观锁？")]),t._v(" "),s("p",[t._v("悲观锁总是假设最坏的情况，"),s("strong",[t._v("认为共享资源每次被访问的时候就会出现问题")]),t._v("(比如共享数据被修改)，所以"),s("strong",[t._v("每次在获取资源操作的时候都会上锁")]),t._v("，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程。")]),t._v(" "),s("p",[s("strong",[t._v("定义")])]),t._v(" "),s("p",[t._v("悲观锁认为操作数据时会有并发冲突，因此在访问数据前就先上锁。")]),t._v(" "),s("ul",[s("li",[t._v("阻塞型锁；")]),t._v(" "),s("li",[t._v("常通过数据库或同步关键字加锁；")]),t._v(" "),s("li",[t._v("一旦加锁，其他线程/事务就必须等待。")])]),t._v(" "),s("p",[s("em",[s("strong",[t._v("优点")])])]),t._v(" "),s("ul",[s("li",[t._v("安全，能够保证数据操作的正确性和一致性。")])]),t._v(" "),s("p",[s("em",[s("strong",[t._v("缺点")])])]),t._v(" "),s("ul",[s("li",[t._v("并发性能较差，在高并发的情况下，会造成大量的线程阻塞，降低系统的性能")]),t._v(" "),s("li",[t._v("容易导致死锁或性能瓶颈")])]),t._v(" "),s("p",[s("em",[s("strong",[t._v("典型代表")])])]),t._v(" "),s("p",[t._v("比如：Java 中 的 "),s("code",[t._v("synchronized")]),t._v(" 和 "),s("code",[t._v("ReentrantLock")]),t._v(" 等独占锁，数据库中的行级锁和表级锁。")]),t._v(" "),s("h3",{attrs:{id:"如何实现乐观锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何实现乐观锁"}},[t._v("#")]),t._v(" 如何实现乐观锁？")]),t._v(" "),s("h4",{attrs:{id:"版本控制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#版本控制"}},[t._v("#")]),t._v(" 版本控制")]),t._v(" "),s("p",[t._v("在操作共享资源之前，先读取数据的版本号，然后将操作结果与当前版本号进行比较，")]),t._v(" "),s("ul",[s("li",[t._v("如果版本号一致，则可以进行操作，")]),t._v(" "),s("li",[t._v("如果版本号不一致，则说明数据已被其他线程修改，需要回滚并重试。")])]),t._v(" "),s("div",{staticClass:"language-sql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 数据库中加一个 version 字段，每次更新时带上旧版本号并 +1")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("UPDATE")]),t._v(" product\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SET")]),t._v(" stock "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" stock "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" version "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" version "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" id "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("100")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("AND")]),t._v(" version "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("5")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br")])]),s("h4",{attrs:{id:"时间戳机制-timestamp"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#时间戳机制-timestamp"}},[t._v("#")]),t._v(" 时间戳机制（Timestamp）")]),t._v(" "),s("ul",[s("li",[t._v("和版本号类似，每次更新时检查上次修改时间。")]),t._v(" "),s("li",[t._v("适用于对“最后修改时间”有天然依赖的业务逻辑。")])]),t._v(" "),s("div",{staticClass:"language-sql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("UPDATE")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("table")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SET")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" update_time "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'2025-01-01 12:00:00'")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("h4",{attrs:{id:"cas-算法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cas-算法"}},[t._v("#")]),t._v(" CAS 算法")]),t._v(" "),s("p",[t._v("CAS 的全称是 "),s("strong",[t._v("Compare And Swap（比较与交换）")]),t._v("，用于实现乐观锁，被广泛应用于各大框架中。")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("CAS 的思想很简单，"),s("strong",[t._v("就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新")]),t._v("。")])]),t._v(" "),s("li",[s("p",[t._v("是一个原子操作，底层依赖于一条 CPU 的原子指令。")])]),t._v(" "),s("li",[s("p",[t._v("在 Java 中，"),s("code",[t._v("AtomicInteger")]),t._v(", "),s("code",[t._v("AtomicLong")]),t._v(", "),s("code",[t._v("AtomicReference")]),t._v(" 这些都是基于乐观锁的典型实现。")])]),t._v(" "),s("li",[s("p",[t._v("在高并发下无需加锁，但可能会出现 ABA 问题。")])])]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("AtomicInteger")]),t._v(" counter "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("AtomicInteger")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\ncounter"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("compareAndSet")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 如果当前是0，就更新为1")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br")])]),s("blockquote",[s("p",[s("strong",[t._v("原子操作")]),t._v(" 即最小不可拆分的操作，也就是说操作一旦开始，就不能被打断，直到操作完成。")])]),t._v(" "),s("h4",{attrs:{id:"数据库唯一索引控制幂等-也是一种乐观控制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数据库唯一索引控制幂等-也是一种乐观控制"}},[t._v("#")]),t._v(" 数据库唯一索引控制幂等（也是一种乐观控制）")]),t._v(" "),s("p",[t._v("通过业务唯一约束 + 插入失败来做并发控制，比如消息幂等性处理：")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("INSERT")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("INTO")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("message_log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("id"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" content"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("VALUES")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("1001")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" 'message'"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("--")]),t._v(" 如果"),s("span",{pre:!0,attrs:{class:"token constant"}},[t._v("ID")]),t._v("重复插入失败，说明已处理过\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br")])]),s("h3",{attrs:{id:"如何实现悲观锁"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何实现悲观锁"}},[t._v("#")]),t._v(" 如何实现悲观锁？")]),t._v(" "),s("p",[t._v("悲观锁的实现方式主要有两种：基于数据库的悲观锁和基于代码的悲观锁。")]),t._v(" "),s("ol",[s("li",[s("p",[s("strong",[t._v("基于数据库的悲观锁")])]),t._v(" "),s("p",[t._v("基于数据库的悲观锁是通过"),s("strong",[t._v("数据库的锁机制")]),t._v("来实现的。在数据库中，可以通过 "),s("code",[t._v("SELECT ... FOR UPDATE")]),t._v(" 语句或 "),s("code",[t._v("SELECT ... FOR SHARE")]),t._v(" 语句来获取悲观锁。")]),t._v(" "),s("ul",[s("li",[t._v("当一个事务执行 "),s("code",[t._v("SELECT ... FOR UPDATE")]),t._v(" 语句时，数据库会将所选的行加上"),s("strong",[t._v("排他锁")]),t._v("，其他事务"),s("strong",[t._v("不能修改")]),t._v("这些行；")]),t._v(" "),s("li",[t._v("当一个事务执行 "),s("code",[t._v("SELECT ... FOR SHARE")]),t._v(" 语句时，数据库会将所选的行加上"),s("strong",[t._v("共享锁")]),t._v("，其他事务"),s("strong",[t._v("只能读取")]),t._v("这些行，不能修改。在使用完锁后，需要及时释放锁，避免长时间占用数据库资源。")])])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("基于代码的悲观锁")])]),t._v(" "),s("p",[t._v("基于代码的悲观锁是通过程序代码来实现的。在 Java 中，"),s("strong",[t._v("可以使用 "),s("code",[t._v("synchronized")]),t._v(" 关键字或 "),s("code",[t._v("Lock")]),t._v(" 接口来实现悲观锁")]),t._v("。")]),t._v(" "),s("ul",[s("li",[t._v("使用 "),s("code",[t._v("synchronized")]),t._v(" 关键字时，需要"),s("strong",[t._v("在方法或代码块上加锁")]),t._v("，以确保同一时间只有一个线程可以执行这段代码；")]),t._v(" "),s("li",[t._v("使用 "),s("code",[t._v("Lock")]),t._v(" 接口时，需要先获取锁（"),s("strong",[t._v("调用 "),s("code",[t._v("lock()")]),t._v(" 方法")]),t._v("），然后执行操作，最后释放锁（调用 "),s("strong",[s("code",[t._v("unlock()")]),t._v(" 方法")]),t._v("），以确保同一时间只有一个线程可以操作共享资源。")])])])]),t._v(" "),s("h3",{attrs:{id:"对比总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#对比总结"}},[t._v("#")]),t._v(" 对比总结")]),t._v(" "),s("table",[s("thead",[s("tr",[s("th",[t._v("特性")]),t._v(" "),s("th",[t._v("悲观锁")]),t._v(" "),s("th",[t._v("乐观锁")])])]),t._v(" "),s("tbody",[s("tr",[s("td",[t._v("加锁方式")]),t._v(" "),s("td",[t._v("操作前加锁")]),t._v(" "),s("td",[t._v("操作后校验")])]),t._v(" "),s("tr",[s("td",[t._v("性能")]),t._v(" "),s("td",[t._v("较低（有锁竞争）")]),t._v(" "),s("td",[t._v("高（无锁，但可能重试）")])]),t._v(" "),s("tr",[s("td",[t._v("适用场景")]),t._v(" "),s("td",[t._v("写多并发高")]),t._v(" "),s("td",[t._v("读多写少、冲突小")])]),t._v(" "),s("tr",[s("td",[t._v("实现方式")]),t._v(" "),s("td",[s("code",[t._v("synchronized")]),t._v(", "),s("code",[t._v("ReentrantLock")]),t._v(", "),s("code",[t._v("FOR UPDATE")])]),t._v(" "),s("td",[t._v("版本号、时间戳、CAS、唯一索引")])])])]),t._v(" "),s("h3",{attrs:{id:"项目中如何选择"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#项目中如何选择"}},[t._v("#")]),t._v(" 项目中如何选择？")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("库存扣减、金融交易类高并发写场景")]),t._v(" → 乐观锁优先（如版本号）")]),t._v(" "),s("li",[s("strong",[t._v("复杂修改操作、强一致场景（如银行转账）")]),t._v(" → 悲观锁")]),t._v(" "),s("li",[t._v("如果使用 MySQL，读多写少的场景更适合乐观锁，否则可能死锁、锁表。")])]),t._v(" "),s("h2",{attrs:{id:"学习参考"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#学习参考"}},[t._v("#")]),t._v(" 学习参考")]),t._v(" "),s("ul",[s("li",[s("p",[s("a",{attrs:{href:"https://javaguide.cn/java/concurrent/java-concurrent-questions-02.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Java并发常见面试题总结（中） | JavaGuide(Java面试 + 学习指南)"),s("OutboundLink")],1)])]),t._v(" "),s("li",[s("p",[s("a",{attrs:{href:"https://www.sharkchili.com/pages/ad63b9/",target:"_blank",rel:"noopener noreferrer"}},[t._v("JUC包下各种锁使用详解 | Shark Chili"),s("OutboundLink")],1)])])])])}),[],!1,null,null,null);s.default=_.exports}}]);