(window.webpackJsonp=window.webpackJsonp||[]).push([[116],{446:function(v,_,t){"use strict";t.r(_);var e=t(1),a=Object(e.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"spring-ioc-和-aop-详解"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#spring-ioc-和-aop-详解"}},[v._v("#")]),v._v(" Spring IoC 和 AOP 详解")]),v._v(" "),_("h2",{attrs:{id:"spring-ioc"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#spring-ioc"}},[v._v("#")]),v._v(" Spring IoC")]),v._v(" "),_("blockquote",[_("p",[v._v("什么是 IoC 控制反转")])]),v._v(" "),_("p",[v._v("IoC "),_("strong",[v._v("（Inversion of Control:控制反转）是一种设计思想")]),v._v("，而不是一个具体的技术实现。")]),v._v(" "),_("p",[v._v("IoC 的思想就是：将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。")]),v._v(" "),_("p",[v._v("注意：IoC 并非 Spring 特有，在其他语言中也有应用。")]),v._v(" "),_("blockquote",[_("p",[v._v("为什么叫控制反转？")])]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("控制")]),v._v("：指的是对象创建（实例化、管理）的权力")]),v._v(" "),_("li",[_("strong",[v._v("反转")]),v._v("：控制权交给外部环境（Spring 框架、IoC 容器）")])]),v._v(" "),_("blockquote",[_("p",[v._v("什么是 IoC 容器")])]),v._v(" "),_("p",[v._v("在 Spring 中， IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。")]),v._v(" "),_("p",[v._v("工作流程：")]),v._v(" "),_("ol",[_("li",[v._v("IoC 容器实例化对象并存储起来，")]),v._v(" "),_("li",[v._v("函数（比如 "),_("code",[v._v("main")]),v._v("）需要哪个对象就往 IoC 容器拿就好。")])]),v._v(" "),_("p",[v._v("简单来说，就是"),_("strong",[v._v("起到了一个中间站的作用")]),v._v("。")]),v._v(" "),_("blockquote",[_("p",[v._v("总结")])]),v._v(" "),_("p",[v._v("Spring IoC 是 Spring 框架的核心特性之一。")]),v._v(" "),_("p",[v._v("它通过 IoC 容器来管理对象，实现了控制反转和依赖注入。")]),v._v(" "),_("p",[v._v("在 Spring 中，IoC 容器负责管理对象的创建和依赖关系的维护，应用程序只需要通过 IoC 容器获取所需的对象即可。")]),v._v(" "),_("p",[_("em",[v._v("在出现 IOC 之前，项目中是如何使用 Bean 的？")])]),v._v(" "),_("p",[v._v('在 Spring 框架的出现之前，项目中通常使用【手动创建】和【管理对象】的方式来使用 "bean"，尤其是在 JavaEE（现在称为 Jakarta EE）开发中。下面是在出现 IOC（控制反转）和 Spring 之前，项目中如何使用 "bean" 的一些常见做法：')]),v._v(" "),_("ol",[_("li",[_("strong",[v._v("手动创建对象：")]),v._v(" 在没有 Spring 框架的情况下，开发人员需要手动实例化和管理对象。这意味着你需要在代码中直接使用 "),_("code",[v._v("new")]),v._v(" 关键字来创建对象，然后自行处理对象的生命周期。（例如 new 对象，结合 get 方法使用）")]),v._v(" "),_("li",[_("strong",[v._v("工厂模式：")]),v._v(" 开发人员可能会使用工厂模式来创建对象。这涉及创建一个工厂类，其中包含创建和管理对象的逻辑。这种方式可以将对象的创建和使用分离开，但仍然需要手动管理对象的生命周期。")]),v._v(" "),_("li",[_("strong",[v._v("单例模式：")]),v._v(" 在很多情况下，开发人员会使用单例模式来确保系统中只有一个实例。这可以通过在类中添加一个私有构造函数和一个静态方法来实现。但这仍然需要手动管理单例实例的创建和使用。")]),v._v(" "),_("li",[_("strong",[v._v("依赖关系管理：")]),v._v(" 在没有 IOC 容器的情况下，开发人员需要手动处理对象之间的依赖关系。这可能会导致代码中充斥着对象之间的创建和注入逻辑。")]),v._v(" "),_("li",[_("strong",[v._v("手动资源释放：")]),v._v(" 在对象使用完毕后，开发人员需要手动释放资源，比如关闭数据库连接、释放文件句柄等。")])]),v._v(" "),_("p",[v._v("总之，在没有 IOC 和 Spring 框架之前，项目的代码可能会更加繁琐和冗长，需要开发人员手动管理对象的创建、注入和生命周期。Spring 框架的出现极大地简化了这些过程，通过 IOC 容器和依赖注入，让开发人员更专注于业务逻辑，而无需过多关注对象的创建和管理。")]),v._v(" "),_("h2",{attrs:{id:"说说循环依赖"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#说说循环依赖"}},[v._v("#")]),v._v(" 说说循环依赖")]),v._v(" "),_("h3",{attrs:{id:"什么是循环依赖"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是循环依赖"}},[v._v("#")]),v._v(" 什么是循环依赖？")]),v._v(" "),_("p",[v._v("循环依赖指的是"),_("strong",[v._v("多个 Bean 之间相互依赖，导致无法完成实例化")]),v._v("。常见的两种情况：")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("构造器循环依赖")]),v._v("（Spring "),_("strong",[v._v("无法")]),v._v(" 解决，会抛出异常）")]),v._v(" "),_("li",[_("strong",[v._v("Setter/字段注入循环依赖")]),v._v("（Spring "),_("strong",[v._v("可以")]),v._v(" 解决，通过三级缓存）")])]),v._v(" "),_("blockquote",[_("p",[v._v("简单说就是自己依赖自己，或者和别的 Bean 相互依赖。")])]),v._v(" "),_("p",[v._v("只有"),_("strong",[v._v("单例的 Bean")]),v._v(" 才存在循环依赖的情况，"),_("strong",[v._v("原型")]),v._v("(Prototype)情况下，Spring 会直接抛出异常。原因很简单，AB 循环依赖，A 实例化的时候，发现依赖 B，创建 B 实例，创建 B 的时候发现需要 A，创建 A1 实例······无限套娃，直接把系统干垮。")]),v._v(" "),_("h3",{attrs:{id:"spring-可以解决哪些情况的循环依赖"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#spring-可以解决哪些情况的循环依赖"}},[v._v("#")]),v._v(" Spring 可以解决哪些情况的循环依赖？")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("当循环依赖的实例都采用 setter 方法注入的时候，Spring 可以解决。")])]),v._v(" "),_("li",[_("p",[v._v("都采用构造器注入的时候，不可以解决。")])]),v._v(" "),_("li",[_("p",[v._v("构造器注入和 setter 注入同时存在的时候，需要分情况。")]),v._v(" "),_("ul",[_("li",[v._v("原因是 Spring 在创建 Bean 时默认会根据自然排序进行创建。比如 A 会先于 B 进行创建。")]),v._v(" "),_("li",[v._v("Spring "),_("strong",[v._v("优先使用构造器注入")]),v._v("，setter 注入是在构造器注入后才发生的。")]),v._v(" "),_("li",[_("strong",[v._v("解决方案：")]),v._v(" "),_("ul",[_("li",[v._v("使用 "),_("code",[v._v("@Lazy")]),v._v(" 让某个 Bean 延迟加载。")]),v._v(" "),_("li",[v._v("改用 setter 注入，完全避免构造器循环依赖问题。")])])])])])]),v._v(" "),_("h3",{attrs:{id:"那-spring-怎么解决循环依赖的呢"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#那-spring-怎么解决循环依赖的呢"}},[v._v("#")]),v._v(" 那 Spring 怎么解决循环依赖的呢？")]),v._v(" "),_("p",[v._v("Spring 主要通过 "),_("strong",[v._v("三级缓存（三级 Map）")]),v._v(" 解决循环依赖问题，解决 "),_("strong",[v._v('"setter 方式注入"')]),v._v(" 的循环依赖。")]),v._v(" "),_("ul",[_("li",[v._v("简单来说：Spring 通过提前暴露 Bean 的 ObjectFactory，让依赖的 "),_("code",[v._v("Bean")]),v._v(" 先拿到一个"),_("strong",[v._v("代理对象")]),v._v("，从而完成初始化。")])]),v._v(" "),_("p",[_("strong",[v._v("三级缓存介绍")]),v._v("：")]),v._v(" "),_("ol",[_("li",[_("strong",[v._v("一级缓存")]),v._v("："),_("code",[v._v("singletonObjects")]),v._v(" —— 存放 "),_("strong",[v._v("完全实例化的 Bean")]),v._v("（已初始化完成）。")]),v._v(" "),_("li",[_("strong",[v._v("二级缓存")]),v._v("："),_("code",[v._v("earlySingletonObjects")]),v._v(" —— 存放 "),_("strong",[v._v("实例化但未初始化的 Bean")]),v._v("。")]),v._v(" "),_("li",[_("strong",[v._v("三级缓存")]),v._v("："),_("code",[v._v("singletonFactories")]),v._v(" —— 存放 "),_("strong",[v._v("可以创建 Bean 代理的工厂")]),v._v("（"),_("code",[v._v("ObjectFactory")]),v._v("）。")])]),v._v(" "),_("p",[_("strong",[v._v("三级缓存的作用")]),v._v("：")]),v._v(" "),_("p",[v._v("三级缓存的核心作用是 "),_("strong",[v._v("提前暴露对象")]),v._v("，使 Spring 在创建 Bean 的过程中，即使发生循环依赖，也能获取到对象的引用。")]),v._v(" "),_("h3",{attrs:{id:"三级缓存如何工作"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三级缓存如何工作"}},[v._v("#")]),v._v(" 三级缓存如何工作？")]),v._v(" "),_("blockquote",[_("p",[v._v("（1）实例化 Bean（创建对象）")])]),v._v(" "),_("ul",[_("li",[v._v("Spring 先 "),_("strong",[v._v("创建 Bean 的原始对象")]),v._v("，")]),v._v(" "),_("li",[v._v("但"),_("strong",[v._v("不初始化")]),v._v("，并"),_("strong",[v._v("放入三级缓存（singletonFactories）")]),v._v("。")])]),v._v(" "),_("blockquote",[_("p",[v._v("（2）提前暴露对象（放入二级缓存）")])]),v._v(" "),_("ul",[_("li",[v._v("如果发现该 Bean 存在循环依赖，Spring 会"),_("strong",[v._v("从三级缓存中获取 Factory")]),v._v("，")]),v._v(" "),_("li",[_("strong",[v._v("提前暴露早期对象")]),v._v("，放入"),_("strong",[v._v("二级缓存（earlySingletonObjects）")]),v._v("。")])]),v._v(" "),_("blockquote",[_("p",[v._v("（3）属性注入（完成依赖）")])]),v._v(" "),_("ul",[_("li",[v._v("Spring 继续"),_("strong",[v._v("实例化依赖的 Bean")]),v._v("，并"),_("strong",[v._v("从二级缓存获取")]),v._v("已暴露的 Bean，完成注入。")]),v._v(" "),_("li",[v._v("解决循环依赖。")])]),v._v(" "),_("blockquote",[_("p",[v._v("（4）初始化完成（放入一级缓存）")])]),v._v(" "),_("ul",[_("li",[v._v("Bean 初始化完成后，移除二级缓存的对象，放入一级缓存 "),_("code",[v._v("singletonObjects")]),v._v("。")]),v._v(" "),_("li",[v._v("这样，下次直接从一级缓存中取，避免重复创建。")])]),v._v(" "),_("h3",{attrs:{id:"为什么需要三级缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要三级缓存"}},[v._v("#")]),v._v(" 为什么需要三级缓存？")]),v._v(" "),_("ul",[_("li",[v._v("如果只有二级缓存（直接存放 Bean），A 和 B 都是未初始化状态，Spring 无法代理 A 或 B。")]),v._v(" "),_("li",[v._v("三级缓存 可以让 Spring 提前暴露 Factory，"),_("strong",[v._v("创建代理对象")]),v._v("，在 A 需要 B 时，可以拿到代理 B，而不是未初始化的 B。")])]),v._v(" "),_("h2",{attrs:{id:"autowired-的实现原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#autowired-的实现原理"}},[v._v("#")]),v._v(" @Autowired 的实现原理？")]),v._v(" "),_("p",[v._v("Spring 中的 "),_("code",[v._v("@Autowired")]),v._v(" 是"),_("strong",[v._v("自动注入")]),v._v("的核心注解，用于将依赖的 Bean "),_("strong",[v._v("自动注入到目标对象中")]),v._v("。")]),v._v(" "),_("ul",[_("li",[v._v("它的底层主要依赖 "),_("strong",[_("code",[v._v("BeanPostProcessor")]),v._v(" 机制")]),v._v("，")]),v._v(" "),_("li",[v._v("在 Bean 创建的不同阶段"),_("strong",[v._v("解析依赖并进行注入")]),v._v("。")])]),v._v(" "),_("blockquote",[_("p",[_("code",[v._v("@Autowired")]),v._v(" 的执行流程：")])]),v._v(" "),_("p",[v._v("Spring 处理 "),_("code",[v._v("@Autowired")]),v._v(" 主要涉及两个核心组件：")]),v._v(" "),_("ol",[_("li",[_("code",[v._v("AutowiredAnnotationBeanPostProcessor")]),v._v(" "),_("ul",[_("li",[v._v("继承自 "),_("code",[v._v("BeanPostProcessor")]),v._v("，在 "),_("strong",[v._v("Bean 初始化前后")]),v._v("处理依赖注入。")]),v._v(" "),_("li",[v._v("解析 "),_("code",[v._v("@Autowired")]),v._v(" 注解，找到需要注入的 Bean 并完成依赖注入。")])])]),v._v(" "),_("li",[_("code",[v._v("DefaultListableBeanFactory#resolveDependency")]),v._v(" "),_("ul",[_("li",[v._v("负责根据 "),_("code",[v._v("@Autowired")]),v._v(" 需求，"),_("strong",[v._v("在 Spring 容器中查找匹配的 Bean")]),v._v(" 并返回。")])])])]),v._v(" "),_("blockquote",[_("p",[v._v("依赖查找逻辑：")])]),v._v(" "),_("ol",[_("li",[_("strong",[v._v("按类型查找")]),v._v("（默认按 "),_("code",[v._v("byType")]),v._v(" 查找 Bean）。")]),v._v(" "),_("li",[_("strong",[v._v("按名称匹配")]),v._v("（如果有 "),_("code",[v._v("@Qualifier")]),v._v("）。")]),v._v(" "),_("li",[v._v("如果存在多个匹配的 Bean：\n"),_("ul",[_("li",[v._v("如果某个 Bean 标注 "),_("code",[v._v("@Primary")]),v._v("，优先注入。")]),v._v(" "),_("li",[v._v("如果带 "),_("code",[v._v('@Qualifier("beanName")')]),v._v("，则按名称匹配。")]),v._v(" "),_("li",[v._v("如果没有唯一的匹配，会报 "),_("code",[v._v("NoUniqueBeanDefinitionException")]),v._v(" 异常。")])])])]),v._v(" "),_("h2",{attrs:{id:"spring-bean"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#spring-bean"}},[v._v("#")]),v._v(" Spring Bean")]),v._v(" "),_("h3",{attrs:{id:"什么是-bean"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是-bean"}},[v._v("#")]),v._v(" 什么是 Bean？")]),v._v(" "),_("p",[v._v("简单来说，Bean 代指的就是那些"),_("strong",[v._v("被 IoC 容器所管理的对象")]),v._v("。")]),v._v(" "),_("p",[v._v("工作流程：")]),v._v(" "),_("blockquote",[_("p",[v._v("在应用程序"),_("strong",[v._v("运行时")])])]),v._v(" "),_("p",[v._v("Spring IoC 容器会根据 Bean 的定义和配置，创建对应的 Bean 对象，并对其进行初始化和依赖注入等操作。")]),v._v(" "),_("p",[v._v("一旦 Bean 对象被创建并注入了依赖关系，就可以被其他对象所引用和使用了。")]),v._v(" "),_("blockquote",[_("p",[v._v("在应用程序"),_("strong",[v._v("结束时")])])]),v._v(" "),_("p",[v._v("Spring IoC 容器会对 Bean 对象进行销毁操作，释放资源，从而完成 Bean 的生命周期。")]),v._v(" "),_("h3",{attrs:{id:"将一个类声明为-bean-的注解有哪些"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#将一个类声明为-bean-的注解有哪些"}},[v._v("#")]),v._v(" 将一个类声明为 Bean 的注解有哪些?")]),v._v(" "),_("ul",[_("li",[_("p",[_("code",[v._v("@Component")]),v._v("：通用的注解，可标注任意类为 "),_("code",[v._v("Spring")]),v._v(" 组件。")]),v._v(" "),_("p",[v._v("如果一个 Bean 不知道属于哪个层，可以使用 "),_("code",[v._v("@Component")]),v._v(" 注解标注。("),_("code",[v._v("config")]),v._v(" 配置层常用)")])]),v._v(" "),_("li",[_("p",[_("code",[v._v("@Repository")]),v._v(": 对应持久层即 "),_("code",[v._v("Dao")]),v._v(" 层，主要用于数据库相关操作。")])]),v._v(" "),_("li",[_("p",[_("code",[v._v("@Service")]),v._v(" : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。")])]),v._v(" "),_("li",[_("p",[_("code",[v._v("@Controller")]),v._v(" : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 "),_("code",[v._v("Service")]),v._v(" 层返回数据给前端页面。")])])]),v._v(" "),_("h3",{attrs:{id:"component-和-bean-的区别是什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#component-和-bean-的区别是什么"}},[v._v("#")]),v._v(" @Component 和 @Bean 的区别是什么？")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("使用方式不同")]),v._v(" "),_("ul",[_("li",[_("p",[_("code",[v._v("@Component")]),v._v(" 注解作用于"),_("strong",[v._v("类")]),v._v("，")])]),v._v(" "),_("li",[_("p",[v._v("而 "),_("code",[v._v("@Bean")]),v._v(" 注解作用于"),_("strong",[v._v("方法")]),v._v("。")])])])]),v._v(" "),_("li",[_("p",[v._v("装配方式不同")]),v._v(" "),_("ul",[_("li",[_("p",[_("code",[v._v("@Component")]),v._v(" 通常是"),_("strong",[v._v("通过类路径扫描来自动侦测以及自动装配")]),v._v("到 Spring 容器中（我们可以使用 "),_("code",[v._v("@ComponentScan")]),v._v(" 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。")])]),v._v(" "),_("li",[_("p",[_("code",[v._v("@Bean")]),v._v(" 注解通常是我们在标有该注解的方法中定义产生这个 bean,"),_("code",[v._v("@Bean")]),v._v("告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。")]),v._v(" "),_("blockquote",[_("p",[v._v("简单来说，就是告诉 Spring，这个方法会返回一个对象，需要被 Spring 管理，当需要使用这个对象的时候，就可以通过注入的方式来获取它。")])])])])]),v._v(" "),_("li",[_("p",[_("code",[v._v("@Bean")]),v._v(" 注解比 "),_("code",[v._v("@Component")]),v._v(" 注解的自定义性更强")]),v._v(" "),_("ul",[_("li",[v._v("很多地方我们只能通过 "),_("code",[v._v("@Bean")]),v._v(" 注解来注册 bean。比如当我们"),_("strong",[v._v("引用第三方库中的类需要装配到 "),_("code",[v._v("Spring")]),v._v(" 容器时，则只能通过 "),_("code",[v._v("@Bean")]),v._v(" 来实现")]),v._v("。")])])])]),v._v(" "),_("h3",{attrs:{id:"哪些注解可以用来注入-bean"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#哪些注解可以用来注入-bean"}},[v._v("#")]),v._v(" 哪些注解可以用来注入 Bean？")]),v._v(" "),_("p",[v._v("有三种：")]),v._v(" "),_("ul",[_("li",[v._v("Spring 内置的 "),_("code",[v._v("@Autowired")])]),v._v(" "),_("li",[v._v("JDK 内置的 "),_("code",[v._v("@Resource")]),v._v(" 和 "),_("code",[v._v("@Inject")])])]),v._v(" "),_("h3",{attrs:{id:"autowired-和-resource-的区别是什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#autowired-和-resource-的区别是什么"}},[v._v("#")]),v._v(" @Autowired 和 @Resource 的区别是什么？")]),v._v(" "),_("ol",[_("li",[_("p",[_("code",[v._v("@Autowired")]),v._v(" 是 Spring 提供的注解，"),_("code",[v._v("@Resource")]),v._v(" 是 JDK 提供的注解。")])]),v._v(" "),_("li",[_("p",[_("code",[v._v("Autowired")]),v._v(" 默认的注入方式为"),_("code",[v._v("byType")]),v._v("（根据类型进行匹配），"),_("code",[v._v("@Resource")]),v._v("默认注入方式为 "),_("code",[v._v("byName")]),v._v("（根据名称进行匹配）。")])]),v._v(" "),_("li",[_("p",[v._v("当一个接口存在多个实现类的情况下，"),_("code",[v._v("@Autowired")]),v._v(" 和 "),_("code",[v._v("@Resource")]),v._v(" 都需要通过名称才能正确匹配到对应的 Bean。")]),v._v(" "),_("ul",[_("li",[_("p",[_("code",[v._v("Autowired")]),v._v(" 可以通过 "),_("code",[v._v("@Qualifier")]),v._v(" 注解来显式指定名称，")])]),v._v(" "),_("li",[_("p",[_("code",[v._v("@Resource")]),v._v("可以通过 "),_("code",[v._v("name")]),v._v(" 属性来显式指定名称。")])])])])]),v._v(" "),_("table",[_("thead",[_("tr",[_("th",[_("strong",[v._v("对比项")])]),v._v(" "),_("th",[_("strong",[_("code",[v._v("@Autowired")])])]),v._v(" "),_("th",[_("strong",[_("code",[v._v("@Resource")])])])])]),v._v(" "),_("tbody",[_("tr",[_("td",[v._v("来源")]),v._v(" "),_("td",[v._v("Spring 提供的自动注入方式")]),v._v(" "),_("td",[v._v("JDK "),_("code",[v._v("javax.annotation")]),v._v(" 提供")])]),v._v(" "),_("tr",[_("td",[v._v("注入方式")]),v._v(" "),_("td",[v._v("默认按类型（byType）匹配")]),v._v(" "),_("td",[v._v("默认按名称（byName）匹配")])]),v._v(" "),_("tr",[_("td",[v._v("可与 "),_("code",[v._v("@Qualifier")]),v._v(" 配合")]),v._v(" "),_("td",[v._v("支持")]),v._v(" "),_("td",[v._v("不支持 "),_("code",[v._v("@Qualifier")])])]),v._v(" "),_("tr",[_("td",[v._v("是否支持 "),_("code",[v._v("@Primary")])]),v._v(" "),_("td",[v._v("支持")]),v._v(" "),_("td",[v._v("不支持")])])])]),v._v(" "),_("h3",{attrs:{id:"什么是-bean-的作用域"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是-bean-的作用域"}},[v._v("#")]),v._v(" 什么是 Bean 的作用域？")]),v._v(" "),_("p",[v._v("Bean 的作用域指的是：Bean 实例在容器中存在的范围。")]),v._v(" "),_("p",[v._v("通过配置 Bean 的作用域，可以控制在何种情况下容器会创建新的 Bean 实例，以及何时销毁 Bean 实例。")]),v._v(" "),_("h3",{attrs:{id:"bean-的作用域有哪些"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#bean-的作用域有哪些"}},[v._v("#")]),v._v(" Bean 的作用域有哪些?")]),v._v(" "),_("p",[v._v("Spring 框架提供了以下 5 种作用域：")]),v._v(" "),_("ol",[_("li",[_("code",[v._v("singleton")]),v._v("：单例模式，一个 Bean 在整个应用中只有一个实例（默认模式）。")]),v._v(" "),_("li",[_("code",[v._v("prototype")]),v._v("：原型模式，每次请求获取 Bean 时，都会创建一个新的实例。")]),v._v(" "),_("li",[_("code",[v._v("request")]),v._v("：请求作用域，每个 HTTP 请求都会创建一个新的实例。")]),v._v(" "),_("li",[_("code",[v._v("session")]),v._v("：会话作用域，每个 HTTP 会话都会创建一个新的实例。")]),v._v(" "),_("li",[_("code",[v._v("application/global-session")]),v._v("：全局会话作用域，每个 Web 应用在启动时创建一个 Bean（应用 Bean），该 bean 仅在当前应用启动时间内有效。")])]),v._v(" "),_("p",[v._v("**注意：**作用域为 "),_("code",[v._v("request")]),v._v("、"),_("code",[v._v("session")]),v._v(" 和 "),_("code",[v._v("global-session")]),v._v(" 的 Bean 只有在 Web 应用中才能使用。")]),v._v(" "),_("blockquote",[_("p",[v._v("配置方式")])]),v._v(" "),_("p",[v._v("可以使用 "),_("code",[v._v("@Scope")]),v._v(" 注解来指定 Bean 的作用域。")]),v._v(" "),_("p",[v._v("1、注解形式")]),v._v(" "),_("div",{staticClass:"language-java line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-java"}},[_("code",[_("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[v._v("@Configuration")]),v._v("\n"),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("public")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("class")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("AppConfig")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("{")]),v._v("\n    "),_("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[v._v("@Bean")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),v._v("name "),_("span",{pre:!0,attrs:{class:"token operator"}},[v._v("=")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token string"}},[v._v('"userService"')]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),v._v("\n    "),_("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[v._v("@Scope")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),_("span",{pre:!0,attrs:{class:"token string"}},[v._v('"singleton"')]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),v._v("\n    "),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("public")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("UserService")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token function"}},[v._v("userService")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("{")]),v._v("\n        "),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("return")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("new")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token class-name"}},[v._v("UserServiceImpl")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(";")]),v._v("\n    "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("}")]),v._v("\n"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("}")]),v._v("\n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br"),_("span",{staticClass:"line-number"},[v._v("2")]),_("br"),_("span",{staticClass:"line-number"},[v._v("3")]),_("br"),_("span",{staticClass:"line-number"},[v._v("4")]),_("br"),_("span",{staticClass:"line-number"},[v._v("5")]),_("br"),_("span",{staticClass:"line-number"},[v._v("6")]),_("br"),_("span",{staticClass:"line-number"},[v._v("7")]),_("br"),_("span",{staticClass:"line-number"},[v._v("8")]),_("br")])]),_("p",[v._v("2、xml 形式")]),v._v(" "),_("div",{staticClass:"language-xml line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-xml"}},[_("code",[_("span",{pre:!0,attrs:{class:"token tag"}},[_("span",{pre:!0,attrs:{class:"token tag"}},[_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("<")]),v._v("bean")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token attr-name"}},[v._v("id")]),_("span",{pre:!0,attrs:{class:"token attr-value"}},[_("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[v._v("=")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v('"')]),v._v("userService"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v('"')])]),v._v(" "),_("span",{pre:!0,attrs:{class:"token attr-name"}},[v._v("class")]),_("span",{pre:!0,attrs:{class:"token attr-value"}},[_("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[v._v("=")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v('"')]),v._v("com.example.UserService"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v('"')])]),v._v(" "),_("span",{pre:!0,attrs:{class:"token attr-name"}},[v._v("scope")]),_("span",{pre:!0,attrs:{class:"token attr-value"}},[_("span",{pre:!0,attrs:{class:"token punctuation attr-equals"}},[v._v("=")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v('"')]),v._v("singleton"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v('"')])]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(">")])]),v._v("\n    "),_("span",{pre:!0,attrs:{class:"token comment"}},[v._v("\x3c!-- ... --\x3e")]),v._v("\n"),_("span",{pre:!0,attrs:{class:"token tag"}},[_("span",{pre:!0,attrs:{class:"token tag"}},[_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("</")]),v._v("bean")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(">")])]),v._v("\n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br"),_("span",{staticClass:"line-number"},[v._v("2")]),_("br"),_("span",{staticClass:"line-number"},[v._v("3")]),_("br")])]),_("h3",{attrs:{id:"单例-bean-的线程安全问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#单例-bean-的线程安全问题"}},[v._v("#")]),v._v(" 单例 Bean 的线程安全问题")]),v._v(" "),_("blockquote",[_("p",[v._v("原因")])]),v._v(" "),_("p",[v._v("单例 Bean 存在线程问题，主要是因为"),_("strong",[v._v("当多个线程操作同一个对象的时候存在资源竞争")]),v._v("。")]),v._v(" "),_("blockquote",[_("p",[v._v("有两种常见的解决方法")])]),v._v(" "),_("ol",[_("li",[v._v("在 Bean 中尽量"),_("strong",[v._v("避免定义可变的成员变量")]),v._v("。")]),v._v(" "),_("li",[v._v("在类中定义一个 "),_("code",[v._v("ThreadLocal")]),v._v(" 成员变量，将需要的可变成员变量保存在 "),_("code",[v._v("ThreadLocal")]),v._v(" 中（推荐）。")])]),v._v(" "),_("blockquote",[_("p",[v._v("无状态的 bean 是线程安全的")])]),v._v(" "),_("p",[v._v("不过，大部分 Bean 实际都是无状态（没有实例变量）的（比如 Dao、Service），这种情况下，Bean 是线程安全的。")]),v._v(" "),_("h3",{attrs:{id:"bean-的生命周期了解么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#bean-的生命周期了解么"}},[v._v("#")]),v._v(" Bean 的生命周期了解么？")]),v._v(" "),_("p",[v._v("Bean 的生命周期可以分为以下几个阶段：")]),v._v(" "),_("ol",[_("li",[_("strong",[v._v("实例化")]),v._v("：容器根据 Bean 的定义创建一个 Bean 实例。")]),v._v(" "),_("li",[_("strong",[v._v("填充属性")]),v._v("：容器将 Bean 的属性赋值给相应的属性或构造函数参数。")]),v._v(" "),_("li",[_("strong",[v._v("初始化")]),v._v("：容器会调用 Bean 的初始化方法，可以通过实现 InitializingBean 接口或在配置文件中指定 init-method 方法来定义 Bean 的初始化方法。")]),v._v(" "),_("li",[_("strong",[v._v("使用")]),v._v("：容器将 Bean 实例化后，可以直接使用它了。")]),v._v(" "),_("li",[_("strong",[v._v("销毁")]),v._v("：当容器关闭时，会调用 Bean 的销毁方法，可以通过实现 DisposableBean 接口或在配置文件中指定 destroy-method 方法来定义 Bean 的销毁方法。")])]),v._v(" "),_("blockquote",[_("p",[v._v("Bean 的处理过程可以干扰吗？")])]),v._v(" "),_("p",[v._v("可以通过改一些配置信息来进行干扰。")]),v._v(" "),_("blockquote",[_("p",[v._v("需要注意的点")])]),v._v(" "),_("p",[v._v("如果 Bean 实现了 DisposableBean 接口或指定了 destroy-method 方法，容器会自动调用 Bean 的销毁方法。")]),v._v(" "),_("p",[v._v("但如果应用程序是非正常关闭的，如直接关闭 JVM 进程，容器就无法进行正常的销毁操作，这时需要通过注册钩子函数，在 JVM 关闭时手动调用销毁方法。")]),v._v(" "),_("h2",{attrs:{id:"spring-aop"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#spring-aop"}},[v._v("#")]),v._v(" Spring AOP")]),v._v(" "),_("h3",{attrs:{id:"谈谈自己对于-aop-的了解"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#谈谈自己对于-aop-的了解"}},[v._v("#")]),v._v(" 谈谈自己对于 AOP 的了解")]),v._v(" "),_("p",[v._v("AOP（Aspect-Oriented Programming，面向切面编程）"),_("strong",[v._v("是一种编程范式")]),v._v("，它通过将程序的横切关注点（如日志、事务、权限控制等）从业务逻辑中剥离出来，并通过切面与业务逻辑进行解耦，从而提高程序的模块化、可维护性和可扩展性。")]),v._v(" "),_("p",[v._v("其中"),_("strong",[v._v("核心是使用动态代理技术")]),v._v("，在运行时生成代理对象，并将切面织入到目标对象的方法调用过程中。")]),v._v(" "),_("blockquote",[_("p",[v._v("实现方式")])]),v._v(" "),_("p",[v._v("Spring 框架提供了两种方式来实现 AOP：")]),v._v(" "),_("ol",[_("li",[v._v("基于代理的 AOP：通过运行时生成代理对象并将切面织入到目标对象的方法调用过程中来实现 AOP。可以通过 "),_("code",[v._v("JDK")]),v._v(" 动态代理（对象实现了某个接口的情况下使用）或者 "),_("code",[v._v("CGLIB")]),v._v(" 动态代理来实现。")]),v._v(" "),_("li",[v._v("基于字节码的 AOP：通过在编译期间修改字节码来实现 AOP。可以使用 "),_("code",[v._v("AspectJ")]),v._v(" 框架来实现。")])]),v._v(" "),_("blockquote",[_("p",[v._v("AOP 切面编程设计到的 5 个专业术语")])]),v._v(" "),_("p",[v._v("AOP 的核心概念是切面（Aspect）、连接点（Join Point）、切点（Pointcut）、通知（Advice）和织入（Weaving）。")]),v._v(" "),_("ul",[_("li",[v._v("切面（Aspect）：一个关注点的模块化，这个关注点跨越多个对象，通常解决的是与业务无关的问题。")]),v._v(" "),_("li",[v._v("连接点（Join Point）：程序执行过程中的某个特定点，如方法的调用、异常抛出等。")]),v._v(" "),_("li",[v._v("切点（Pointcut）：一组连接点的集合，通常使用表达式指定。")]),v._v(" "),_("li",[v._v("通知（Advice）：在切面的连接点上执行的动作，包括前置通知、后置通知、环绕通知、异常通知和最终通知等。")]),v._v(" "),_("li",[v._v("织入（Weaving）：将切面应用到目标对象并创建新的代理对象的过程。")])]),v._v(" "),_("blockquote",[_("p",[v._v("优点")])]),v._v(" "),_("ol",[_("li",[v._v("代码复用：将横切关注点分离出来，可以避免在业务逻辑中重复编写相同的代码。")]),v._v(" "),_("li",[v._v("可维护性：将横切关注点与业务逻辑分离，在修改横切关注点时不会影响业务逻辑的实现。")]),v._v(" "),_("li",[v._v("可扩展性：可以方便地添加新的切面，而不需要修改现有的业务逻辑代码。")]),v._v(" "),_("li",[v._v("提高程序的可读性：将横切关注点从业务逻辑中分离出来，可以使业务逻辑更加清晰明了。")])]),v._v(" "),_("h3",{attrs:{id:"spring-aop-和-aspectj-aop-有什么区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#spring-aop-和-aspectj-aop-有什么区别"}},[v._v("#")]),v._v(" Spring AOP 和 AspectJ AOP 有什么区别？")]),v._v(" "),_("ol",[_("li",[v._v("AOP 集成了 AspectJ。")]),v._v(" "),_("li",[v._v("AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作。")]),v._v(" "),_("li",[v._v("AspectJ 的功能更加强大。")]),v._v(" "),_("li",[v._v("切面少，两者性能差异不大；切面太多的话，最好选择 AspectJ，会更快。")])])])}),[],!1,null,null,null);_.default=a.exports}}]);