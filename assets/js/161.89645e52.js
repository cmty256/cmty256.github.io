(window.webpackJsonp=window.webpackJsonp||[]).push([[161],{489:function(t,e,a){"use strict";a.r(e);var r=a(1),s=Object(r.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"模板方法模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#模板方法模式"}},[t._v("#")]),t._v(" 模板方法模式")]),t._v(" "),e("h2",{attrs:{id:"模板方法模式基本介绍"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#模板方法模式基本介绍"}},[t._v("#")]),t._v(" 模板方法模式基本介绍")]),t._v(" "),e("ol",[e("li",[t._v("模板方法模式（TemplateMethodPattern），又叫模板模式(TemplatePattern)，在一个 "),e("code",[t._v("抽象类")]),t._v(" 公开定义了执行它的方法的模板。它的 "),e("code",[t._v("子类")]),t._v(" 可以按需要重写方法实现，但调用将以 "),e("code",[t._v("抽象类")]),t._v(" 中定义的方式进行。")]),t._v(" "),e("li",[t._v("简单说，模板方法模式定义一个操作中的算法的骨架，而将一些步骤延迟到 "),e("code",[t._v("子类")]),t._v(" 中，使得 "),e("code",[t._v("子类")]),t._v(" 可以不改变一个算法的结构，就可以重定义该算法的某些特定步骤。")]),t._v(" "),e("li",[t._v("这种类型的设计模式属于行为型模式。")])])])}),[],!1,null,null,null);e.default=s.exports}}]);